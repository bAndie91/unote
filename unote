#!/usr/bin/env python
# -*- coding: utf-8 -*-

try:
	import gtk
except ImportError:
	import gi
	from gi import pygtkcompat
	pygtkcompat.enable() 
	pygtkcompat.enable_gtk(version='2.0')
	import gtk
import glib
import pango
import gobject
import time
import re
import glob
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory
from datetime import datetime
from dateutil.relativedelta import relativedelta
import xattr
import errno
import traceback
try:
	import inotifyx
except ImportError:
	import inotify.adapters
	import inotify.calls
	import inotify.constants

# Backward compatibility
try:
	unicode
except NameError:
	class unicode(str):
		pass
if not hasattr(pango, 'SCALE_X_LARGE'):
	pango.SCALE_X_LARGE = 1.44
if not hasattr(gtk.TreeStore, 'insert_with_values'):
	gtk.TreeStore.insert_with_values = gtk.TreeStore.insert_with_valuesv



APPNAME = 'unote'
try:
	NOTES_DIR = sys.argv[1]
except IndexError:
	NOTES_DIR = os.path.expanduser('~/Notes')
NOTESFILE_EXCLUDES = ['*~', '*.bak']
# define what counts as a word in task texts and search query text:
taskbody_word_re = r'[#\w-]'


NOTES_DIR = NOTES_DIR.rstrip(os.path.sep)
NOTES_ARCHIVE_DIR = os.path.join(NOTES_DIR, '.Archive')
NOTES_ARCHIVE_DIR = NOTES_ARCHIVE_DIR.rstrip(os.path.sep)


def getsizeofrecursive(x):
	size = 0
	if hasattr(x, '__iter__'):
		for y in x: size += getsizeofrecursive(y)
	else:
		size += sys.getsizeof(x)
	return size

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def filenameize(s):
	#s = re.sub(r'(^|/)\.\.(/|$)', '', s)
	s = re.sub(os.path.sep, '⁄', s)
	return s

def find_nonexistent_file(directory, preferred_filename):
	filename = preferred_filename
	n = 1
	while True:
		filepath = os.path.join(directory, filename)
		if not os.path.exists(filepath): break
		n += 1
		filename = '%s (%d)' % (preferred_filename, n)
	return filepath

def str_replace_last(s, f, r):
	pos = s.rfind(f)
	if pos == -1: return s
	return s[0:pos] + r + s[pos+len(f):]

def run_async(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			os.execvp(cmd, args)
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def question(msg, stock_yes=None, stock_no=None, parent=None):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_no is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_NO).hide()
		btn_no = gtk.Button(label=stock_no[0], stock=stock_no[1])
		dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
		btn_no.show()
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = gtk.Button(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget


class Patch(object):
	"""
	License: Public domain (CC0)
	Author: Isaac Turner 2016/12/05
	Source: https://gist.github.com/noporpoise/16e731849eb1231e86d78f9dfeca3abc
	"""
	import difflib
	_no_eol = '\ No newline at end of file'
	_hdr_pat = re.compile('^@@ -(\d+),?(\d+)? \+(\d+),?(\d+)? @@$')

	@classmethod
	def make_patch(selfclass, a, b):
	  """
	  Get unified string diff between two strings. Trims top two lines.
	  Returns empty string if strings are identical.
	  """
	  diffs = selfclass.difflib.unified_diff(a.splitlines(True),b.splitlines(True),n=0)
	  try: X, X = next(diffs),next(diffs)
	  except StopIteration: pass
	  return ''.join([d if d[-1] == '\n' else d+'\n'+selfclass._no_eol+'\n' for d in diffs])
	
	@classmethod
	def apply_patch(selfclass, s, patch, revert=False):
	  """
	  Apply patch to string s to recover newer string.
	  If revert is True, treat s as the newer string, recover older string.
	  """
	  s = s.splitlines(True)
	  p = patch.splitlines(True)
	  t = ''
	  i = sl = 0
	  (midx,sign) = (1,'+') if not revert else (3,'-')
	  while i < len(p) and p[i].startswith(("---","+++")): i += 1 # skip header lines
	  while i < len(p):
	    m = selfclass._hdr_pat.match(p[i])
	    if not m:
	      raise Exception("Bad patch -- regex mismatch [line "+str(i)+"]")
	    l = int(m.group(midx))-1 + (m.group(midx+1) == '0')
	    if sl > l or l > len(s):
	      raise Exception("Bad patch -- bad line num [line "+str(i)+"]")
	    t += ''.join(s[sl:l])
	    sl = l
	    i += 1
	    while i < len(p) and p[i][0] != '@':
	      if i+1 < len(p) and p[i+1][0] == '\\': line = p[i][:-1]; i += 2
	      else: line = p[i]; i += 1
	      if len(line) > 0:
	        if line[0] == sign or line[0] == ' ': t += line[1:]
	        sl += (line[0] != sign)
	  t += ''.join(s[sl:])
	  return t

def get_word_halves(text, pos, word_re=None):
	if word_re is None: word_re = r'\w'
	text_before, text_after = text[0:pos], text[pos:]
	first_half = re.search(word_re + r'*\Z', text_before, re.U).group(0)
	second_half = re.search(r'^'+word_re+r'*', text_after, re.U).group(0)
	return first_half, second_half

def current_word(text, pos, word_re=None):
	return ''.join(get_word_halves(text, pos, word_re))

class TextEntry(gtk.Entry):
	def get_text(self):
		return unicode(super(self.__class__, self).get_text())

class TextBuffer(gtk.TextBuffer):
	# at least this many char addition+removal triggers an undo checkpoint:
	undo_checkpoint_threshold = 12
	undo_stack_size_limit = 2*1024*1024
	
	def __init__(self, *args):
		self._eventhandlers = []
		super(self.__class__, self).__init__(*args)
		self.create_tag('headline', scale=pango.SCALE_X_LARGE)
		self.create_tag('strike', strikethrough=True)
		self.create_tag('bold', weight=pango.WEIGHT_ULTRABOLD)
		self.create_tag('code', family='Monospace')
		self.create_tag('link', foreground='blue', underline=pango.UNDERLINE_SINGLE)
		self.create_tag('hidden', invisible=True)
		self.create_tag('alert', foreground='red')
		self._changed_event_handle = super(self.__class__, self).connect('changed', self._undo_checkpoint)
		self.reinit('')
	def reinit(self, text=''):
		self.set_text(text)
		self.undo_stack = []
		self.undo_stack_index = -1
		self.undo_reference_content = text
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return unicode(self.get_slice(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True))
	def get_buffer_halves(self, textiter=None):
		if textiter is None: textiter = self.cursor_iter
		return tuple(map(unicode, (self.get_slice(self.get_start_iter(), textiter, include_hidden_chars=True), self.get_slice(textiter, self.get_end_iter(), include_hidden_chars=True))))
	def get_word_halves(self, textiter, word_re):
		first_half, second_half = self.get_buffer_halves(textiter)
		return get_word_halves(first_half+second_half, len(first_half), word_re)
	def get_word_boundaries(self, textiter, word_re=None):
		text_before, text_after = self.get_buffer_halves(textiter)
		word_first_half, word_second_half = self.get_word_halves(textiter, word_re)
		cursor_offset = len(text_before)
		start_offset = cursor_offset - len(word_first_half)
		end_offset = cursor_offset + len(word_second_half)
		return self.get_iter_at_offset(start_offset), self.get_iter_at_offset(end_offset)
	def get_word(self, textiter, word_re=None):
		return ''.join(self.get_word_halves(textiter, word_re=word_re))
	def get_current_word(self, word_re=None):
		return self.get_word(self.cursor_iter, word_re=word_re)
	@property
	def cursor_iter(self):
		return self.get_iter_at_mark(self.get_insert())
	@property
	def cursor_pos(self):
		#return len(self.get_buffer_halves()[0])
		return self.get_property('cursor-position')
	@cursor_pos.setter
	def cursor_pos(self, pos):
		self.place_cursor(self.get_iter_at_offset(pos))
	def replace_current_word(self, replacement, word_re=None):
		start, end = self.get_word_boundaries(self.cursor_iter, word_re)
		self.delete(start, end)
		self.insert(start, replacement)
	def connect(self, eventname, *args):
		self._eventhandlers.append(super(self.__class__, self).connect(eventname, *args))
	def disconnect(self, eventhandle):
		super(self.__class__, self).disconnect(eventhandle)
		self._eventhandlers.remove(eventhandle)
	def disable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_block(eventhandle)
	def enable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_unblock(eventhandle)
	def get_selected_text(self):
		if self.get_has_selection():
			begin, end = self.get_selection_bounds()
			return self.get_slice(begin, end, include_hidden_chars=True)
		else:
			return ''
	def replace_selected_text(self, replacement):
		if self.get_has_selection():
			self.delete_selection(False, True)
			begin_offset = self.cursor_pos
			end_offset = begin_offset + len(replacement)
			self.insert_at_cursor(replacement)
			self.select_range(self.get_iter_at_offset(begin_offset), self.get_iter_at_offset(end_offset))
	def replace_text(self, start_offset, length, replacement):
		self.delete(self.get_iter_at_offset(start_offset), self.get_iter_at_offset(start_offset+length))
		self.insert(self.get_iter_at_offset(start_offset), replacement)
	def get_current_line_boundaries(self):
		text = self.get_text_all()
		cur = self.cursor_pos
		sol = text.rfind('\n', 0, cur) + 1
		eol = text.find('\n', cur)
		if eol == -1: eol = len(text)
		return sol, eol
	def get_current_line(self):
		sol, eol = list(map(self.get_iter_at_offset, self.get_current_line_boundaries()))
		return self.get_slice(sol, eol, include_hidden_chars=True)
	def apply_tag_by_name(self, tagname, pos1, pos2):
		super(self.__class__, self).apply_tag_by_name(tagname, self.get_iter_at_offset(pos1), self.get_iter_at_offset(pos2))
	def remove_all_tags(self, start=None, end=None):
		if start is None: start = self.get_start_iter()
		if end is None: end = self.get_end_iter()
		super(self.__class__, self).remove_all_tags(start, end)
	def get_tag_by_name(self, tagname):
		return self.get_tag_table().lookup(tagname)
	def _undo_checkpoint(self, *X):
		def chardistance(a, b):
			import difflib
			distance = 0
			for change in difflib.ndiff(a, b):
				if change[0] in ['+', '-']:
					distance += 1
			return distance
		text = self.get_text_all()
		if chardistance(self.undo_reference_content, text) > self.undo_checkpoint_threshold:
			self.create_undo_checkpoint()
	def create_undo_checkpoint(self):
		text = self.get_text_all()
		patch = Patch.make_patch(self.undo_reference_content, text)
		if patch != '':
			del self.undo_stack[self.undo_stack_index+1:]
			self.undo_stack.append((patch, self.cursor_pos))
			self.undo_stack_index += 1
			self.undo_reference_content = text
			while getsizeofrecursive(self.undo_stack) > self.undo_stack_size_limit:
				del self.undo_stack[0]
				self.undo_stack_index -= 1
	def undo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index >= 0:
			patch, pos = self.undo_stack[self.undo_stack_index]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=True)
			self.handler_block(self._changed_event_handle)
			self.set_text(replacement)
			self.handler_unblock(self._changed_event_handle)
			self.cursor_pos = pos
			self.undo_stack_index -= 1
			self.undo_reference_content = replacement
	def redo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index < len(self.undo_stack) - 1:
			patch, pos = self.undo_stack[self.undo_stack_index + 1]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=False)
			self.handler_block(self._changed_event_handle)
			self.set_text(replacement)
			self.handler_unblock(self._changed_event_handle)
			self.cursor_pos = pos
			self.undo_stack_index += 1
			self.undo_reference_content = replacement

class CompletionSuggestionsBox(gtk.TextView):
	def __init__(self, *args):
		self._all_items = []
		self._filterer_word = ''
		self._shown_items = []
		self._suggestion_index = -1
		super(self.__class__, self).__init__(*args)
		self.set_wrap_mode(gtk.WRAP_WORD)
		self.set_editable(False)
		self.get_buffer().create_tag('active_suggestion', background='yellow', weight=pango.WEIGHT_BOLD)
		self.get_buffer().create_tag('inactive_suggestion')
		# style
		try:
			bgcolor = gtk.gdk.Color('lightgrey')
		except TypeError:
			bgcolor = gtk.gdk.Color(211, 211, 211)
		self.modify_base(gtk.STATE_NORMAL, bgcolor)
	def filter_for(self, word):
		last_suggestion = self.current_suggestion
		self._filterer_word = word
		self._shown_items = [item for item in self._all_items if self._filter_func(word, item)]
		idx = -1
		if last_suggestion is not None:
			try: idx = self._shown_items.index(last_suggestion)
			except ValueError: pass
		self.set_suggestion_index(idx)
	@staticmethod
	def _filter_func(query, item):
		if query == item['word']: return False
		query_norm = re.sub(r'[^\w-]', '', query, flags=re.I|re.U)
		return item['word'].find(query_norm) > -1
	def next_suggestion(self):
		idx = self._suggestion_index + 1
		if idx >= len(self._shown_items): idx = 0
		self.set_suggestion_index(idx)
		return self.current_suggestion_word
	def previous_suggestion(self):
		idx = self._suggestion_index - 1
		if idx < 0: idx = len(self._shown_items)-1
		self.set_suggestion_index(idx)
		return self.current_suggestion_word
	@property
	def current_suggestion(self):
		if len(self._shown_items) == 0: return None
		return self._shown_items[self._suggestion_index]
	@property
	def current_suggestion_word(self):
		return (self.current_suggestion or {'word': None})['word']
	def set_suggestion_index(self, idx=-1):
		textbuffer = self.get_buffer()
		textbuffer.set_text('')
		for i, item in enumerate(self._shown_items):
			tagname = 'active_suggestion' if i == idx else 'inactive_suggestion'
			textbuffer.insert_with_tags_by_name(textbuffer.get_end_iter(), item['label'], tagname)
			textbuffer.insert(textbuffer.get_end_iter(), ' ')
		self._suggestion_index = idx
	def set_items(self, items):
		for item in items:
			assert isinstance(item, dict)
			assert 'word' in item
		self._all_items = items[:]
		for item in self._all_items:
			if 'label' not in item or item['label'] is None:
				item['label'] = item['word']
		self.filter_for(self._filterer_word)

class TreeModelRow(object):
	"""proxy class for inextensible gtk.TreeModelRow"""
	def __init__(self, treemodelrow, upstream_treemodel):
		self.real_treemodelrow = treemodelrow
		self.upstream_treemodel = upstream_treemodel
	@property
	def path(self):
		return self.real_treemodelrow.path
	@property
	def iter(self):
		return self.real_treemodelrow.iter
	@property
	def model(self):
		return self.real_treemodelrow.model
	def __getitem__(self, item):
		item = self.upstream_treemodel.get_column_num(item)
		answer = gtk.TreeModel.get(self.model, self.iter, item)[0]
		return self.upstream_treemodel.convert_cell(item, answer)
	def __setitem__(self, item, value):
		item = self.upstream_treemodel.get_column_num(item)
		self.real_treemodelrow[item] = value
	def __len__(self):
		return self.real_treemodelrow.__len__()

class TreeModelProxy(object):
	@staticmethod
	def _proxy_foreach(model, treepath, treeiter, _proxy_userdata):
		func = _proxy_userdata['func']
		userdata = _proxy_userdata['userdata']
		derived_model = _proxy_userdata['derived_model']
		return func(derived_model, treepath, treeiter, userdata)

class TreeModelFilter(gtk.TreeModelFilter):
	_proxy_implemented = ['__getitem__', 'foreach', 'get', 'get_value']
	def __init__(self, upstream_treemodel, treemodel_filter):
		self._proxy_real_treemodel = treemodel_filter
		self._proxy_upstream_treemodel = upstream_treemodel
	def __getitem__(self, item):
		answer = self._proxy_real_treemodel.__getitem__(item)
		return TreeModelRow(answer, self._proxy_upstream_treemodel)
	def foreach(self, func, userdata):
		_proxy_userdata = {'func': func, 'userdata': userdata, 'derived_model': self}
		self._proxy_real_treemodel.foreach(TreeModelProxy._proxy_foreach, _proxy_userdata)
	def get(self, row, *columns):
		raise(Exception('unimplemented'))
	def get_value(self, treeiter, column):
		raise(Exception('unimplemented'))
	def __len__(self):
		return len(self._proxy_real_treemodel)
	def __getattribute__(self, attr):
		if attr.startswith('_proxy_') or attr in self._proxy_implemented:
			return object.__getattribute__(self, attr)
		else:
			return object.__getattribute__(self._proxy_real_treemodel, attr)

class TreeModelSort(gtk.TreeModelSort):
	def __init__(self, basemodel):
		if hasattr(basemodel, '_proxy_upstream_treemodel'):
			self._proxy_upstream_treemodel = basemodel._proxy_upstream_treemodel
		else:
			self._proxy_upstream_treemodel = basemodel
		if hasattr(basemodel, '_proxy_real_treemodel'):
			basemodel = basemodel._proxy_real_treemodel
		super(self.__class__, self).__init__(basemodel)
	def __getitem__(self, item):
		answer = super(self.__class__, self).__getitem__(item)
		return TreeModelRow(answer, self._proxy_upstream_treemodel)
	def foreach(self, func, userdata):
		_proxy_userdata = {'func': func, 'userdata': userdata, 'derived_model': self}
		super(self.__class__, self).foreach(TreeModelProxy._proxy_foreach, _proxy_userdata)
	def get(self, row, *columns):
		raise(Exception('unimplemented'))
	def get_value(self, treeiter, column):
		raise(Exception('unimplemented'))

class TreeStore(gtk.TreeStore):
	__gsignals__ = {
		'changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
	}
	def __init__(self, *columns):
		self.column = {}
		self.reader = {}
		self.empty = []
		types = []
		n = 0
		for col_name, col_type in columns:
			empty_value = None
			if col_type == unicode:
				col_type = str
				self.reader[n] = self.to_unicode
			if col_type == str:
				empty_value = ''
			elif col_type in [int, float]:
				empty_value = 0
			self.empty.append(empty_value)
			types.append(col_type)
			self.column[col_name] = n
			n += 1
		super(self.__class__, self).__init__(*types)
		for event in 'row-changed', 'row-deleted', 'row-inserted', 'rows-reordered':
			self.connect_after(event, self._on_change, event)
	def _on_change(self, *X):
		self.emit('changed')
	@staticmethod
	def to_unicode(s):
		if s is None: return None
		return unicode(s)
	def get_column_num(self, col_name):
		if isinstance(col_name, int): return col_name
		return self.column[col_name]
	def get(self, row, *columns):
		if type(row) == tuple:
			row = self.get_iter(row)  # tree iterator path was given
		if len(columns) == 0:
			return tuple()
		columns = list(columns)
		for i, col in enumerate(columns):
			columns[i] = self.get_column_num(col)
		answer = super(self.__class__, self).get(row, *columns)
		answer = list(answer)
		for i, col_num in enumerate(columns):
			answer[i] = self.convert_cell(col_num, answer[i])
		answer = tuple(answer)
		return answer
	def get_value(self, treeiter, column):
		return super(self.__class__, self).get_value(treeiter, column)
	def convert_cell(self, col_num, cell_value):
		if col_num in self.reader:
			return self.reader[col_num](cell_value)
		return cell_value
	def __getitem__(self, item):
		answer = super(self.__class__, self).__getitem__(item)
		return TreeModelRow(answer, self)
	def append(self, parent, row):
		if type(row) == dict:
			cols = row
			row = self.empty[:]
			for col_name, value in cols.items():
				row[self.get_column_num(col_name)] = value
		return super(self.__class__, self).append(parent, row)
	def set(self, treeiter, *itempairs):
		if len(itempairs) == 0: return
		if type(itempairs[0]) == dict:
			cols = itempairs[0]
			itempairs = []
			for col_name, value in cols.items():
				itempairs.extend([self.get_column_num(col_name), value])
		super(self.__class__, self).set(treeiter, *itempairs)
	def get_iter_root(self):
		if hasattr(super(self.__class__, self), 'get_iter_root'):
			return super(self.__class__, self).get_iter_root()
		else: 
			return self.get_iter_first()
	def get_cells_by_column(self, col_name):
		treeiter = self.get_iter_root()
		while treeiter is not None:
			yield self[treeiter][col_name]
			treeiter = successor_iter(self, treeiter)
	def walk_columns(self, *columns):
		"""yields a sequence of [TreeModelRow, depth, value-1, value-2, ..., value-n] lists
		for depth being the row's level on the tree and value-1 to value-n being the 
		content of cells in the requested columns in each row"""
		treeiter = self.get_iter_root()
		while treeiter is not None:
			row = self[treeiter]
			answer = [row]
			answer.extend(self.get(treeiter, *columns))
			yield answer
			treeiter = successor_iter(self, row.iter)
	def filter_new(self, root=None):
		treemodelfilter = super(self.__class__, self).filter_new(root=root)
		return TreeModelFilter(self, treemodelfilter)

class TreeView(gtk.TreeView):
	__gsignals__ = {
		'menu-popup': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT)),
	}
	def __init__(self, model):
		super(self.__class__, self).__init__(model)
		self.connect('button-press-event', self._on_button_click)
	def _on_button_click(self, widget, event):
		if event.button == 3:
			x, y = int(event.x), int(event.y)
			t = self.get_path_at_pos(x, y)
			if t is not None:
				treepath, tv_col, cell_x, cell_y = t
			else:
				treepath, tv_col, cell_x, cell_y = None, None, None, None
			popup_menu = gtk.Menu()
			if not self.emit('menu-popup', popup_menu, treepath, tv_col, cell_x, cell_y):
				# event is not handled by any handlers, so do it ourself
				if popup_menu.get_children():
					popup_menu.show_all()
					popup_menu.popup(None, None, None, event.button, event.time)
			return True

class Calendar(gtk.Calendar):
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'mark-added': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
		'mark-removed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
	}
	date_format = '%04d-%02d-%02d'
	def __init__(self):
		self._marks = {}
		self.selected_day = (0, 0, 0)
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		# create popup menu
		self.popup_menu = gtk.Menu()
		mi = gtk.MenuItem("Go Today")
		mi.connect('activate', self.gotoday)
		self.popup_menu.append(mi)
		self.popup_menu.show_all()
		# set initial state
		self.gotoday()
		self.connect('key-release-event', self.on_key_press_release)
		self.connect('button-press-event', self.on_mouse_click)
		self.connect('button-release-event', self.on_mouse_clicked)
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	@property
	def selected_day(self):
		return (self.selected_day_year, self.selected_day_month, self.selected_day_day)
	@selected_day.setter
	def selected_day(self, date):
		self.selected_day_year, self.selected_day_month, self.selected_day_day = date[:]
	def on_mouse_click(self, widget, event):
		if event.button == 3:
			self.popup_menu.popup(None, None, None, event.button, event.time)
			return True  # eat the event
	def on_mouse_clicked(self, widget, event):
		if event.button == 1:
			if self.get_date()[2] != 0:
				self.on_user_select_day()
				return False  # let the event pass
	def on_key_press_release(self, widget, event):
		c_year, c_month, c_day = self.get_date()
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			if c_day == self.selected_day[2]:
				self.select_day(0)
				self.selected_day = (0, 0, 0)
			else:
				self.on_user_select_day()
		elif event.keyval in [gtk.gdk.keyval_from_name('Enter'), gtk.gdk.keyval_from_name('Return')]:
			s_year, s_month, s_day = self.selected_day[:]
			space_key_event = event.copy()
			space_key_event.keyval = int(gtk.gdk.keyval_from_name('space'))
			self.emit('key-press-event', space_key_event)
			self.emit('key-release-event', space_key_event)
			m_year, m_month, m_day = self.get_date()
			if m_day == 0:
				m_year, m_month, m_day = s_year, s_month, s_day
			self.do_mark(m_year, m_month, m_day)
			self.selected_day = (s_year, s_month, s_day)
			self.on_paging()
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Up'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=-1)
			self.select_month(date.month - 1, date.year)
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Down'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=+1)
			self.select_month(date.month - 1, date.year)
	def gotoday(self, *X):
		now = time.localtime()
		self.select_month(now.tm_mon - 1, now.tm_year)
		self.select_day(now.tm_mday)
		self.selected_day = (now.tm_year, now.tm_mon, now.tm_mday)
		self.on_paging()
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in list(self._marks.keys()):
			response.append(date_format % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		self.do_mark(c_year, c_month, c_day)
	def do_mark(self, c_year, c_month, c_day):
		was_marked = False
		for year, month, day in list(self._marks.keys()):
			if year == c_year and month == c_month and c_day == day:
				was_marked = True
				del self._marks[(year, month, day)]
		if was_marked:
			self.emit('mark-removed', self.date_format % (c_year, c_month, c_day))
		else:
			self._marks[(c_year, c_month, c_day)] = True
			self.emit('mark-added', self.date_format % (c_year, c_month, c_day))
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)
		if c_year == self.selected_day[0] and c_month == self.selected_day[1]:
			self.select_day(self.selected_day[2])
	def on_user_select_day(self, *X):
		self.selected_day = self.get_date()

class ActionStockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None, action=None, use_underline=False):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)
			self.set_use_underline(use_underline)
		if action is not None:
			self.connect('activate', action)

def save_treeview_column_sort(tvc):
	Props['field/tasklist/sort-by'] = tvc.get_name
	Props['field/tasklist/sort-order'] = int(tvc.get_sort_order())

def save_treeview_column_width(tvc, Xprop):
	Props['layout/column/%s/width' % tvc.get_name()] = tvc.get_width()

def add_treeview_columns(treeview, columns):
	for col_name, col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_name(col_name)
		tvc.set_title(col_title)
		tvc.set_sort_indicator(True)
		tvc.set_sort_column_id(col_num)
		tvc.set_resizable(True)
		tvc.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
		tvc.set_reorderable(True)
		
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		
		treeview.append_column(tvc)
		width = Props['layout/column/%s/width' % col_name]
		if width is not None:
			tvc.set_fixed_width(int(width))
		else:
			tvc.set_fixed_width(100)
		tvc.connect('notify::width', save_treeview_column_width)
		tvc.connect('clicked', save_treeview_column_sort)

def main_quit():
	save_position()
	# execute outstanding timers
	for iden in list(Timers.keys()):
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()
	# load last opened task
	select_or_load_task_by_file(Props['history/last/opened-task/path'])

def select_or_load_task_by_file(task_file_nonprefixed):
	def find_task_by_file(model, treepath, treeiter, data):
		c_task_file = model[treeiter]['file']
		c_task_file_nonprefixed = strip_path_prefix(c_task_file)
		if c_task_file_nonprefixed == data['file_nonprefixed']:
			data['iter'] = treeiter
			data['text'] = model[treepath]['raw_text']
			return True
	data = {'text': None, 'iter': None, 'file_nonprefixed': task_file_nonprefixed}
	tasklist_view.get_model().foreach(find_task_by_file, data)
	if data['iter'] is not None:
		tasklist_selection.unselect_all()
		tasklist_selection.select_iter(data['iter'])
	else:
		tasklist.foreach(find_task_by_file, data)
		if data['text'] is not None:
			load_task(task_file_nonprefixed, data['text'])

class PropertyTree(dict):
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.savedprops = {}
		self.write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.items():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

class HistoryList(object):
	def __init__(self, size_limit=1024000, items=[], pointer=-1):
		assert pointer < len(items)
		if len(items) > 0 and pointer == -1: pointer = len(items)-1
		assert (len(items) > 0 and pointer > -1) or (len(items) == 0 and pointer == -1)
		super(self.__class__, self).__init__()
		self.stack = items[:]
		self.pointer = pointer
		self.size_limit = size_limit
		self._on_change_func = lambda:None
	def set_size_limit(self, bytes):
		assert isinstance(bytes, int)
		self.size_limit = bytes
	def push(self, item):
		if item != self.currentitem:
			self.stack.insert(self.pointer + 1, item)
			self.pointer += 1
		while sys.getsizeof(self.stack) > self.size_limit:
			if len(self) - self.pointer < self.pointer:
				del self.stack[0]
			else:
				del self.stack[-1]
		self._on_change_func()
	def __len__(self):
		return len(self.stack)
	def __getslice__(self, s, n):
		return self.stack.__getslice__(s, n)
	@property
	def currentitem(self):
		return self.stack[self.pointer] if self.pointer > -1 else None
	def forward(self):
		goindex = self.pointer + 1
		if len(self) > goindex: self.pointer = goindex
		return self.currentitem
	def backward(self):
		goindex = self.pointer - 1
		if goindex > 0: self.pointer = goindex
		return self.currentitem
	@property
	def on_change(self):
		return self._on_change_func
	@on_change.setter
	def on_change(self, func):
		self._on_change_func = func

def strip_path_prefix(s):
	if s is None: return None
	assert s.startswith(NOTES_DIR+os.path.sep)
	return s[len(NOTES_DIR)+1:]

def add_path_prefix(s):
	if s is None: return None
	assert not s.startswith(NOTES_DIR+os.path.sep)
	return os.path.join(NOTES_DIR, s)

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

class DirectoryWatcher(object):
	eventnames = ('IN_MODIFY', 'IN_CREATE', 'IN_DELETE', 'IN_MOVE')
	def __init__(self, directory, callback):
		self._callback_func = callback
		eventmask = 0
		try:
			inotifyx
			backend = 'inotifyx'
			for event in self.eventnames: eventmask |= getattr(inotifyx, event)
		except NameError:
			backend = 'inotify'
			for event in self.eventnames: eventmask |= getattr(inotify.constants, event)
		
		if backend == 'inotifyx':
			inofd = inotifyx.init()
			inotifyx.add_watch(inofd, directory, eventmask)
			inner_callback = self._callback_inotifyx
		else:
			self._inotify = inotify.adapters.Inotify()
			inofd = self._inotify._Inotify__inotify_fd
			self._inotify.add_watch(directory, mask=eventmask)
			inner_callback = self._callback_inotify
		
		glib.io_add_watch(inofd, glib.IO_IN|glib.IO_OUT, inner_callback)
		
	def _callback_inotifyx(self, fd, Xcondition):
		inotifyx.get_events(fd)
		return self._callback_common()
	def _callback_inotify(self, Xfd, Xcondition):
		self._inotify.event_gen(timeout_s=0, yield_nones=False)
		return self._callback_common()
	def _callback_common(self):
		return self._callback_func()

def on_notes_dir_changed():
	load_tasklist()
	return True

def load_tasks():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(NOTES_DIR), topdown=True, onerror=None, followlinks=True):
		for idx, dirname in reversed(list(enumerate(dirnames))):
			if dirname.startswith('.'):
				# don't descent into hidden directories
				del dirnames[idx]
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in NOTESFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			with open(filepath, 'r') as f:
				text = f.read()
				yield unicode(text), unicode(filepath)

def get_tags(text):
	return re.findall(r'(?:^|\s|,)(#[\w-]+)', text, re.I|re.U)

def update_task_in_list(treestore, treeiter, task_text=None, task_file=None, task_mtime=None):
	row = {}
	if task_text is not None:
		row['raw_text'] = task_text
		
		preview = task_text
		charshift = 0
		for s, e, hideranges in find_markup_positions(preview, 'bold'):
			for s, e in hideranges:
				preview = preview[0:s+charshift] + preview[e+charshift:]
				charshift -= e - s
		preview += '\n'
		head, body = preview.split('\n', 1)
		head = re.sub(r'\r', '', head)
		body = re.sub(r'[\r\n]+', ' ', body)
		body = body[0:255] + ('…' if len(body)>255 else '')
		row['headline_markup'] = '%s <span foreground="grey">%s</span>' % (glib.markup_escape_text(head), glib.markup_escape_text(body))
		
		dates = re.findall(r'\bdate:\s*(\S+)', task_text)
		if dates:
			row['date'] = dates[0]
		duedates = re.findall(r'\bdue:\s*(\S+)', task_text)
		if duedates:
			row['due'] = duedates[0]
	if task_file is not None:
		row['file'] = task_file
		if task_mtime is None:
			task_mtime = os.stat(task_file).st_mtime
	if task_mtime is not None:
		row['updated'] = time.strftime('%F %H:%M', time.localtime(task_mtime))
	treestore.set(treeiter, row)

def load_tasklist():
	rows_to_forget = dict([(x[1], x[0]) for x in tasklist.walk_columns('file')])
	for task_text, task_file in load_tasks():
		if task_file in rows_to_forget:
			treeiter = rows_to_forget[task_file].iter
			del rows_to_forget[task_file]
		else:
			treeiter = tasklist.append(None, {})
		update_task_in_list(tasklist, treeiter, task_text, task_file)
	loaded_file_path = add_path_prefix(RuntimeData.get('loaded-task-file'))
	for task_file, row in rows_to_forget.items():
		if loaded_file_path == task_file:
			# currently opened task is gone from the overall task list, close it
			act_close_task()
		tasklist.remove(row.iter)

def on_tasklist_changed(*X):
	timer_once(0.25, process_tasklist)

def sort_tags_by_count(tags):
	return sorted(tags, key='count')

def make_tag_suggestion_list(tags):
	return sort_tags_by_count([{'label': '%s (%d)'%(key, tags[key]), 'word': key, 'count': tags[key]} for key in list(tags.keys())])

def count_tags(model, path, treeiter, data):
	task_text = model[path]['raw_text']
	for tag in get_tags(task_text):
		data[tag] = data.get(tag, 0) + 1

def process_tasklist():
	AllTags.clear()
	tasklist.foreach(count_tags, AllTags)

def save_position():
	filepath = add_path_prefix(RuntimeData.get('loaded-task-file'))
	if filepath is not None and os.path.exists(filepath):
		pos = taskbody_buffer.cursor_pos
		try:
			xattr.setxattr(filepath, 'user.textedit.cursor_position', str(pos))
		except IOError:
			traceback.print_exc()

def load_taskbody(text):
	save_position()
	taskbody_buffer.disable_events()
	taskbody_buffer.reinit(text)
	taskbody_buffer.enable_events()
	parse_taskbody(text)
	calendar.gotoday()

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[m[0:3].lower()]
	except KeyError: pass
	return m

def find_markup_positions(text, markupname):
	def find_coderanges(text):
		# lines between 2 set of triple backticks, and
		# words embraced by backticks
		# (allow to escape first backtick: r'(?<!\\)(?:\\\\)*`(.*?(?<!\\)(?:\\\\)*)`')
		for regex in r'^```[^\n]*\n(.*?)(?<=\n)```', r'(?<!\w)`([^\n]*?(?<!\\)(?:\\\\)*)`(?!\w)':
			for match in re.finditer(regex, text, re.S|re.M):
				yield match.start(1), match.end(1), []
	if markupname == 'headline':
		first_eol = text.find('\n')
		if first_eol > -1:
			yield 0, first_eol, []
		else:
			yield 0, len(text), []
	elif markupname == 'link':
		for match in re.finditer(r'\b([a-z+-]+://[^\s]+)', text, re.I):
			yield match.start(0), match.end(0), []
	elif markupname == 'strike':
		regex = u'^[ \t]*(?:-[ \t]*)?(.+?)([ \t]+(DONE|WONTFIX|OBSOLETED)|[ \t]*(✓|✔|✗|✘|\[(DONE|WONTFIX|OBSOLETED)\]))'
		for match in re.finditer(regex, text, re.U|re.M):
			yield match.start(1), match.end(1), []
	elif markupname in ['bold', 'alert']:
		coderanges = [(s, e) for s, e, h in find_coderanges(text)]
		if markupname == 'bold':
			# words embraced in asterisks, optionally surrounded by brackets or whitespace but nothing else
			for match in re.finditer(r'(^|[\s\(\[\{\<])\*(?!\s|\*)(.+?)(?<!\s|\*)\*(?=[\s\)\]\}\>]|$)', text):
				start, end = match.start(2), match.end(2)
				if all([end < s or start > e for s, e in coderanges]):
					yield start, end, [(start-1, start), (end, end+1)]
		elif markupname == 'alert':
			# a line ending in double exclamation marks, and literal string "<!>"
			for regex in r'^\s*(?:-\s*)?(.+!!)\s*$', r'(<!>)':
				for match in re.finditer(regex, text, re.M):
					start, end = match.start(1), match.end(1)
					if all([end < s or start > e for s, e in coderanges]):
						yield start, end, []
	elif markupname == 'code':
		for start, end, hideranges in find_coderanges(text):
			yield start, end, hideranges
	else:
		raise

def parse_taskbody(text):
	# style and format text
	taskbody_buffer.remove_all_tags()
	for markupname in ['headline', 'link', 'strike', 'bold', 'code', 'alert']:
		for start, end, hideranges in find_markup_positions(text, markupname):
			taskbody_buffer.apply_tag_by_name(markupname, start, end)
			for start, end in hideranges:
				taskbody_buffer.apply_tag_by_name('hidden', start, end)
	
	# find date strings and show them in calendar
	calendar_marks = []
	re_months = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
	for y, m, d in re.findall(r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + re_months + r')-(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + re_months + r')(?:-|\s+)(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	if calendar_marks or re.search(r'\b(date|due):', text, re.I):
		if not calendar.get_visible():
			calendar.gotoday()
		calendar.show()
	else:
		calendar.hide()

def load_task(task_file_nonprefixed, task_text):
	act_close_task()
	load_taskbody(task_text)
	RuntimeData['loaded-task-file'] = task_file_nonprefixed
	RuntimeData['unsaved'] = False
	Props['history/last/opened-task/path'] = task_file_nonprefixed
	taskhistorylist.push(task_file_nonprefixed)
	# restore cursor position:
	filepath = add_path_prefix(task_file_nonprefixed)
	try:
		cursor_pos = xattr.getxattr(filepath, 'user.textedit.cursor_position')
	except IOError as e:
		if e.errno == errno.ENODATA: pass
		else: raise
	else:
		if cursor_pos is not None:
			taskbody_buffer.cursor_pos = int(cursor_pos)
			act_taskbody_view_scroll_to_cursor()

def on_tasklist_selection_change(selection):
	model, iterpaths = selection.get_selected_rows()
	if len(iterpaths) == 0:
		return
	iterpath = iterpaths[0]
	# TODO: support multiple loaded task
	row = model[iterpath]
	loaded_task_file = add_path_prefix(RuntimeData.get('loaded-task-file'))
	if loaded_task_file is not None and loaded_task_file == row['file']:
		return
	load_task(strip_path_prefix(row['file']), row['raw_text'])

def timer_once(sec, func, func_args=(), reschedule=True):
	iden = func.__name__
	if iden in Timers:
		if reschedule:
			glib.source_remove(Timers[iden]['handle'])
			del Timers[iden]
		else:
			return
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.4, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def on_searchbox_icon_clicked(entry, icon_pos, event):
	if icon_pos == 1:
		entry.set_text('')

def successor_iter(model, predecessor):
	"""return the next "heir" in line of succession metaphorically speaking.
	i.e. the first child of the node if there is any, otherwise its next sibling node,
	otherwise its parent node's next sibling."""
	if model.iter_has_child(predecessor):
		return model.iter_nth_child(predecessor, 0)
	else:
		successor = model.iter_next(predecessor)
		if successor is None:
			while True:
				parent = model.iter_parent(predecessor)
				if parent is None: return None
				uncle = model.iter_next(parent)
				if uncle is not None: return uncle
				predecessor = parent
			return None
		return successor

def act_tasklist_select_updown(up=True):
	down = not up
	s_iter = None
	model, s_rows = tasklist_selection.get_selected_rows()
	if len(s_rows) == 0:
		c_iter = None
		s_iter = model.get_iter_root()
	else:
		c_iter = model.get_iter(s_rows[0 if up else -1])
	if c_iter is not None:
		if down:
			s_iter = successor_iter(model, c_iter) or c_iter
		elif up:
			predecessor = model.get_iter_root()
			while predecessor is not None:
				successor = successor_iter(model, predecessor)
				if successor is None:
					s_iter = model.get_iter_root()
					break
				if model.get_path(successor) == model.get_path(c_iter):
					s_iter = predecessor
					break
				predecessor = successor
	if s_iter is not None:
		tasklist_selection.unselect_all()
		tasklist_selection.select_iter(s_iter)

def act_tasklist_select_prevnext(prev=True):
	if prev:
		task_file = taskhistorylist.backward()
	else:
		task_file = taskhistorylist.forward()
	if task_file is not None:
		select_or_load_task_by_file(task_file)

def on_searchbox_keypress(widget, event):
	keys = KeyDetector(event)
	shift_up = keys.up and keys.shift
	shift_down = keys.down and keys.shift
	if shift_up or shift_down:
		act_tasklist_select_updown(shift_up)
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			text, pos = replace_word(searchbox.get_text(), searchbox.get_property('cursor-position'), word, word_re=taskbody_word_re)
			searchbox.set_text(text)
			searchbox.set_position(pos)
		tab_completion_handled = handle_tab_completion(event, complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled

def replace_word(text, pos, word, word_re=None):
	first_half, second_half = get_word_halves(text, pos, word_re)
	new_pre = text[0:pos-len(first_half)] + word + ' '
	new_post = text[pos+len(second_half):]
	return (new_pre + new_post, len(new_pre))

def on_searchbox_keypressed(widget, event):
	query = searchbox.get_text()
	pos = searchbox.get_property('cursor-position')
	c_word = current_word(query, pos, word_re=taskbody_word_re)
	if c_word.startswith('#'):
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(c_word)
	else:
		completion_suggestions_box.hide()

def save_search_query(query):
	query = query.strip()
	if query != '' and query not in savedsearches.get_cells_by_column('query'):
		savedsearches.append(None, [query])

def on_savedsearches_changed(*X):
	timer_once(1.0, act_save_quicksearch_list)

def act_save_quicksearch_list():
	text = ''
	for row, query in savedsearches.walk_columns('query'):
		if query is None: continue
		expandstate = '+' if savedsearches_view.row_expanded(row.path) else '-'
		text += '\t'*(len(row.path)-1) + expandstate + query + '\n'
	Props['field/quicksearch/list'] = text

def load_saved_searches(savedsearches_text):
	prev_level = 0
	prev_iter_on_level = {-1: None}
	to_expand = []
	for tabs, expandstate, query in map(lambda s: re.findall(r'(\t*)([+-]?)(.*)', s)[0], savedsearches_text.split('\n')):
		if query == '': continue
		level = len(tabs)
		parent_iter = prev_iter_on_level[level - 1]
		prev_iter_on_level[level] = savedsearches.append(parent_iter, {'query': query})
		if expandstate == '+':
			to_expand.append(savedsearches.get_path(prev_iter_on_level[level]))
	for treepath in to_expand:
		savedsearches_view.expand_row(treepath, open_all=False)

def on_savedsearches_menu(treeview, popup_menu, treepath, tv_col, cell_x, cell_y):
	if treepath is not None:
		model = treeview.get_model()
		row = model[treepath]
		savedquery = row['query']
		popup_menu.append(ActionStockMenuItem(label=_("Remove '%s'")%savedquery, stock_id=gtk.STOCK_REMOVE, action=lambda *X: model.remove(row.iter)))

def on_savedsearches_selection(selection):
	model, iterpaths = selection.get_selected_rows()
	if len(iterpaths) > 0:
		new_query = ' '.join([model[iterpath]['query'] for iterpath in iterpaths])
		searchbox.set_text(new_query)

def on_tasklist_menu(treeview, popup_menu, c_treepath, tv_col, cell_x, cell_y):
	if c_treepath is not None:
		model, s_treepaths = tasklist_selection.get_selected_rows()
		selected_filepaths = []
		for s_treepath in s_treepaths:
			selected_filepaths.append(model[s_treepath]['file'])
		clicked_filepath = model[c_treepath]['file']
		popup_menu.append(ActionStockMenuItem(label=_("Done this"), stock_id=gtk.STOCK_APPLY, action=lambda *X: act_task_done([clicked_filepath])))
		popup_menu.append(ActionStockMenuItem(label=_("Done selected (%d)")%len(selected_filepaths), stock_id=gtk.STOCK_APPLY, action=lambda *X: act_task_done(selected_filepaths)))
		popup_menu.append(ActionStockMenuItem(label=_("Delete this…"), stock_id=gtk.STOCK_DELETE, action=lambda *X: act_task_delete([clicked_filepath])))

def act_task_done(filepaths):
	for filepath in filepaths:
		subpath = strip_path_prefix(filepath)
		subdir, subfile = os.path.split(subpath)
		newpath = find_nonexistent_file(os.path.join(NOTES_ARCHIVE_DIR, subdir), subfile)
		mkdir(os.path.dirname(newpath))
		act_close_task()
		os.rename(filepath, newpath)

def act_task_delete(filepaths):
	for filepath in filepaths:
		if question(_("Really delete?")+'\n<tt>'+glib.markup_escape_text(filepath)+'</tt>', stock_yes=(None, gtk.STOCK_DELETE), stock_no=(None, gtk.STOCK_CANCEL), parent=main_win):
			act_close_task()
			os.remove(filepath)

def make_tasklist_sortkey(cell, order):
	"""let the alphabetical cells always first, numeric cells second,
	and empty cells be the last part, regardless of the ascending/descending order
	which only applies within each groups"""
	if order == gtk.SORT_ASCENDING:
		if cell == '' or cell is None: sortkey = 'C'
		elif re.search(r'^\d', cell): sortkey = 'B'
		else: sortkey = 'A'
	else:
		if cell == '' or cell is None: sortkey = 'A'
		elif re.search(r'^\d', cell): sortkey = 'B'
		else: sortkey = 'C'
	sortkey += cell or ''
	return sortkey

def tasklist_sort_callback(model, iter_a, iter_b, cb_data):
	cell_a = model[iter_a][cb_data['col_num']]
	cell_b = model[iter_b][cb_data['col_num']]
	col_id, order = cb_data['sort_model'].get_sort_column_id()
	sortkey_a = make_tasklist_sortkey(cell_a, order)
	sortkey_b = make_tasklist_sortkey(cell_b, order)
	return cmp(sortkey_a, sortkey_b)

def filter_tasklist():
	tasklist_filtered.refilter()
	tasklist_top_label.set_text(_("Found: %d") % len(tasklist_filtered))
	
	VisibleTaskTags.clear()
	tasklist_filtered.foreach(count_tags, VisibleTaskTags)
	
	if completion_suggestions_box.get_visible():
		query = searchbox.get_text()
		pos = searchbox.get_property('cursor-position')
		# count each tags how many task would be there if we would add the suggested tag to the search filter
		def count_tags_making_intersection(model, treepath, treeiter, completion_items):
			for item in completion_items:
				newquery, Xpos = replace_word(query, pos, item['word'], word_re=taskbody_word_re)
				include = tasklist_filterer_with_custom_query(model, treeiter, newquery)
				if include: item['count'] += 1
		completion_items = list([{'word': key, 'count': 0} for key in VisibleTaskTags.keys()])
		tasklist_view.get_model().foreach(count_tags_making_intersection, completion_items)
		completion_items = filter(lambda item: item['count']>0, completion_items)
		for item in completion_items:
			item.update({'label': '%s (%d)'%(item['word'], item['count'])})
		completion_items = sort_tags_by_count(completion_items)
		completion_suggestions_box.set_items(completion_items)

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	return tasklist_filterer_with_custom_query(model, treeiter, query)

def tasklist_filterer_with_custom_query(model, treeiter, query):
	if query == '':
		return True
	task_text = model[treeiter]['raw_text']
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = task_text.find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def get_tasklist_treeiter_by_file(q_file):
	treeiter = None
	for c_row, c_file in tasklist.walk_columns('file'):
		if c_file == q_file:
			return c_row.iter
	raise KeyError(_("No row with file=='%s'") % q_file)

def save_task():
	filepath = add_path_prefix(RuntimeData.get('loaded-task-file'))
	if filepath is not None:
		treeiter = get_tasklist_treeiter_by_file(filepath)
		text = tasklist[treeiter]['raw_text']
		with open(filepath, 'w') as f:
			f.write(text)

def on_taskbody_changed(*X):
	RuntimeData['unsaved'] = True
	text = taskbody_buffer.get_text_all()
	# re-parse
	parse_taskbody(text)
	# represent task text in the task list
	loaded_task_file = RuntimeData.get('loaded-task-file')
	if loaded_task_file is None:
		# don't save new task until at least one line is entered,
		# and generate file name from the first line
		m = re.search(r'^\s*(.+?)\n', text)
		if not m: return
		first_line = m.group(1)
		filepath = find_nonexistent_file(NOTES_DIR, filenameize(first_line) + '.txt')
		open(filepath, 'w').write(text)
		RuntimeData['loaded-task-file'] = strip_path_prefix(filepath)
	else:
		loaded_task_file = add_path_prefix(loaded_task_file)
		treeiter = get_tasklist_treeiter_by_file(loaded_task_file)
		update_task_in_list(tasklist, treeiter, task_text=text, task_mtime=time.time())
		# schedule save
		timer_once(5.0, save_task, reschedule=False)

def on_taskbody_typing(textbuffer, textiter, typedtext, length):
	first_half, second_half = textbuffer.get_word_halves(textiter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def on_taskbody_erase(textbuffer, startiter, enditer):
	first_half = textbuffer.get_word_halves(startiter, word_re=taskbody_word_re)[0]
	second_half = textbuffer.get_word_halves(enditer, word_re=taskbody_word_re)[1]
	c_word = first_half+second_half
	act_taskbody_word(c_word, len(first_half))

def act_taskbody_word(word, pos):
	if word.startswith('#') and pos>0:
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(word)
	else:
		completion_suggestions_box.hide()

def act_change_font(*X):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(main_win)
	dlg.set_modal(True)
	dlg.set_font_name(Props['field/taskbody/font'] or textview_get_current_font(taskbody_view)['name'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['field/taskbody/font'] = font_name
		taskbody_view_set_font(font_name)
	dlg.destroy()

def textview_get_current_font(textview):
	pctx = textview.get_pango_context()
	fdsc = pctx.get_font_description()
	return {'name': fdsc.to_string(), 'size': int(fdsc.get_size()/pango.SCALE)}

def taskbody_view_set_font(fontname):
	taskbody_view.modify_font(pango.FontDescription(fontname))
	fontsize = textview_get_current_font(taskbody_view)['size']
	head_tag = taskbody_buffer.get_tag_by_name('headline')
	head_tag.set_property('pixels-below-lines', int(fontsize * 0.8))

def taskbody_view_toggle_wrap(*X):
	wrap_mode = 'WRAP_NONE' if taskbody_view.get_wrap_mode() != gtk.WRAP_NONE else 'WRAP_WORD'
	taskbody_view.set_wrap_mode(getattr(gtk, wrap_mode))
	Props['field/taskbody/wrapmode'] = wrap_mode

def on_taskbody_view_menu(Xtextview, menu):
	pos = 0
	mi = ActionStockMenuItem(label=_("Default Font…"), stock_id=gtk.STOCK_SELECT_FONT, action=act_change_font)
	menu.insert(mi, pos)
	pos += 1
	mi = gtk.CheckMenuItem(label=_("Wrap Lines"))
	mi.set_active(taskbody_view.get_wrap_mode() != gtk.WRAP_NONE)
	mi.connect('toggled', taskbody_view_toggle_wrap)
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	menu.show_all()

class KeyDetector(object):
	def __init__(self, event):
		self.tab = False
		self.backtab = False
		self.control = event.state & gtk.gdk.CONTROL_MASK != 0
		self.shift = event.state & gtk.gdk.SHIFT_MASK != 0
		self.alt = event.state & gtk.gdk.MOD1_MASK != 0
		if not self.control and not self.alt:
			self.tab = event.keyval == gtk.gdk.keyval_from_name('Tab') and not self.shift
			self.backtab = (event.keyval == gtk.gdk.keyval_from_name('Tab') and self.shift) or event.keyval == gtk.gdk.keyval_from_name('ISO_Left_Tab')
		self.enter = event.keyval in [gtk.gdk.keyval_from_name('Return'), gtk.gdk.keyval_from_name('Enter')]
		self.escape = event.keyval == gtk.gdk.keyval_from_name('Escape')
		self.up = event.keyval == gtk.gdk.keyval_from_name('Up')
		self.down = event.keyval == gtk.gdk.keyval_from_name('Down')
		for letter in map(chr, range(ord('a'), ord('z')+1)):
			setattr(self, letter.upper(), event.keyval == gtk.gdk.keyval_from_name(letter))

def handle_tab_completion(event, callback):
	keys = KeyDetector(event)
	if keys.tab:
		completion_suggestions_box.next_suggestion()
		return True  # prevent event propagation
	elif keys.backtab:
		completion_suggestions_box.previous_suggestion()
		return True
	elif keys.control and keys.enter:
		suggestion = completion_suggestions_box.current_suggestion_word
		if suggestion is not None:
			callback(suggestion)
			completion_suggestions_box.hide()
			return True
	return None

def on_taskbody_view_keypress(widget, event):
	keys = KeyDetector(event)
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			taskbody_buffer.replace_current_word(word+' ', word_re=taskbody_word_re)
		tab_completion_handled = handle_tab_completion(event, callback=complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled
	
	if keys.escape:
		completion_suggestions_box.hide()
		return True
	if keys.tab or keys.backtab:
		selected_text = taskbody_buffer.get_selected_text()
		if selected_text != '':
			if keys.tab:
				selected_text = re.sub(r'^(?=.)', '\t', selected_text, flags=re.M)
			elif keys.backtab:
				selected_text = re.sub(r'^\t', '', selected_text, flags=re.M)
			taskbody_buffer.replace_selected_text(selected_text)
		else:
			if keys.tab:
				return False
			elif keys.backtab:
				line = taskbody_buffer.get_current_line()
				if line.startswith('\t'):
					sol, Xeol = taskbody_buffer.get_current_line_boundaries()
					taskbody_buffer.delete(taskbody_buffer.get_iter_at_offset(sol), taskbody_buffer.get_iter_at_offset(sol+1))
		return True
	if keys.control:
		if keys.enter:
			text = taskbody_buffer.get_text_all()
			pos = taskbody_buffer.cursor_pos
			for start, end, Xhideranges in find_markup_positions(text, 'link'):
				if start <= pos < end:
					link = taskbody_buffer.get_text_all()[start:end]
					if link.startswith('file://'):
						link = os.path.expanduser(link[7:])
					run_async('xdg-open', [link])
					return True
			c_word = current_word(text, pos, word_re=taskbody_word_re)
			if c_word.startswith('#'):
				searchbox.set_text(searchbox.get_text() + ' ' + c_word)
				return True
		elif keys.B:
			s = taskbody_buffer.get_selected_text()
			if s.startswith('*') and s.endswith('*') and len(s)>2:
				s = s[1:-1]
			else:
				s = '*' + s + '*'
			taskbody_buffer.replace_selected_text(s)
			return True
		elif keys.Y or (keys.Z and keys.shift):
			taskbody_buffer.redo()
			act_taskbody_view_scroll_to_cursor()
			return True
		elif keys.Z:
			taskbody_buffer.undo()
			act_taskbody_view_scroll_to_cursor()
			return True

def act_taskbody_view_scroll_to_cursor():
	taskbody_view.scroll_to_mark(taskbody_buffer.get_insert(), within_margin=0.33)

def on_taskbody_view_cursor_moved(Xtextview, Xstep_size, Xcount, Xextend_selection):
	first_half, second_half = taskbody_buffer.get_word_halves(taskbody_buffer.cursor_iter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def on_taskbody_view_focus(*X):
	completion_items = make_tag_suggestion_list(AllTags)
	completion_suggestions_box.set_items(completion_items)

def taskbody_insert_line(s):
	pre, post = taskbody_buffer.get_buffer_halves()
	if pre[-1] != '\n': s = '\n' + s
	if post == '' or post[0] != '\n': s = s + '\n'
	taskbody_buffer.insert_at_cursor(s)

def taskbody_remove_text_around_cursor(s):
	"""removes first occurrance of s from taskbody_buffer before the cursor
	or after the cursor, whichever is the nearest.
	removes newline if s is a complete line."""
	pre, post = taskbody_buffer.get_buffer_halves()
	pre_pos = (pre+post).rfind(s, 0, len(pre)+len(s)-2)
	post_pos = post.find(s)
	if pre_pos > -1 and post_pos > -1:
		pre_distance = len(pre) - pre_pos - len(s)
		post_distance = post_pos
		if post_distance < pre_distance:
			remove_from_pos = len(pre)+post_pos
		else:
			remove_from_pos = pre_pos
	elif post_pos > -1:
		remove_from_pos = len(pre)+post_pos
	elif pre_pos > -1:
		remove_from_pos = pre_pos
	else:
		return False
	remove_length = len(s)
	if (remove_from_pos > 0 and (pre+post)[remove_from_pos-1] == '\n' or remove_from_pos == 0) and remove_from_pos+len(s) < len(pre+post) and (pre+post)[remove_from_pos+len(s)] == '\n':
		remove_length = remove_length + 1
	taskbody_buffer.replace_text(remove_from_pos, remove_length, '')

def act_close_task():
	save_position()
	if RuntimeData.get('unsaved'):
		# save the currentlly loaded task now, and leave scheduled save_task() there, 
		# it'll not save the task which it was called upon, but an other one - it's not a problem 
		# since we have auto-saving anyway.
		save_task()
	RuntimeData['loaded-task-file'] = None
	RuntimeData['unsaved'] = False
	taskbody_buffer.reinit('')

def act_new_task():
	act_close_task()
	tasklist_selection.unselect_all()
	taskbody_view.grab_focus()


Timers = {}
Props = PropertyTree()
RuntimeData = {}
AllTags = {}
VisibleTaskTags = {}

main_win = gtk.Window()
paned1 = gtk.HPaned()
paned2h = gtk.HPaned()
paned2v = gtk.VPaned()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2h.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass
try: paned2v.set_position(*map(int, getprops('layout/panel/tasklist/height')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2h.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))
paned2v.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/height', paned.get_position())))

savedsearches = TreeStore(('query', unicode))
savedsearches.connect('changed', on_savedsearches_changed)
savedsearches_view = TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [('query', _("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)
savedsearches_view.connect('menu-popup', on_savedsearches_menu)
savedsearches_view.connect('row-collapsed', on_savedsearches_changed)
savedsearches_view.connect('row-expanded', on_savedsearches_changed)
load_saved_searches(Props['field/quicksearch/list'] or '')

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)
savedsearches_selection.connect('changed', on_savedsearches_selection)

searchbox = TextEntry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.set_icon_from_stock(1, gtk.STOCK_CLEAR)
searchbox.set_tooltip_text(_("""Search expressions:\n
peanut – tasks containing substring "peanut" even in words
#peanut – tasks containing a tag starting with "#peanut"
apple pear – tasks containing both "apple" and "pear" as well
apple, pear – all tasks containing "apple" or "pear" or both
apple NOT pear peach – tasks containing apple but neither pear nor peach"""))
searchbox.connect('changed', on_searchbox_change)
searchbox.connect('key-press-event', on_searchbox_keypress)
searchbox.connect('key-release-event', on_searchbox_keypressed)
searchbox.connect('icon-release', on_searchbox_icon_clicked)

taskhistorylist = HistoryList(items=((Props['history/opened-tasks'] or '').split(chr(0))), pointer=int(Props['history/opened-task-pointer'] or -1))
taskhistorylist.on_change = lambda: (Props.__setitem__('history/opened-tasks', chr(0).join(taskhistorylist[:])), Props.__setitem__('history/opened-task-pointer', str(taskhistorylist.pointer)))

mkdir(NOTES_DIR)
directory_watcher = DirectoryWatcher(directory=NOTES_DIR, callback=on_notes_dir_changed)

tasklist = TreeStore(('headline_markup', unicode), ('raw_text', unicode), ('file', unicode), ('updated', str), ('date', str), ('due', str))
tasklist.connect('row-changed', on_tasklist_changed)
tasklist.connect('row-deleted', on_tasklist_changed)
tasklist.connect('row-inserted', on_tasklist_changed)

tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)
tasklist_sorted = TreeModelSort(tasklist_filtered)
for col_name in 'date', 'due':
	col_num = tasklist.get_column_num(col_name)
	tasklist_sorted.set_sort_func(col_num, tasklist_sort_callback, {'col_name': col_name, 'col_num': col_num, 'sort_model': tasklist_sorted})
tasklist_sorted.set_sort_column_id(tasklist.get_column_num(Props.get('field/tasklist/sort-by', 'due')), int(Props.get('field/tasklist/sort-order', gtk.SORT_ASCENDING)))

tasklist_top_label = gtk.Label()
tasklist_top_label.set_alignment(1, 0)

tasklist_view = TreeView(tasklist_sorted)
tasklist_view_columns_set = {
	'headline_markup': [_("Task"), 'markup', tasklist.get_column_num('headline_markup')],
	'updated': [_("Updated"), 'text', tasklist.get_column_num('updated')],
	'due': [_("Due"), 'text', tasklist.get_column_num('due')],
	'date': [_("Date"), 'text', tasklist.get_column_num('date')],
}
tasklist_view_columns_display_init = []
for col_name in (Props['layout/panel/tasklist/columns-order'] or 'headline_markup\nupdated\ndue\ndate').strip().split('\n'):
	col = tasklist_view_columns_set[col_name][:]
	col.insert(0, col_name)
	tasklist_view_columns_display_init.append(col)
	del col
add_treeview_columns(tasklist_view, tasklist_view_columns_display_init)
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)
tasklist_view.connect('menu-popup', on_tasklist_menu)
tasklist_view.connect('columns-changed', lambda treeview: Props.__setitem__('layout/panel/tasklist/columns-order', '\n'.join([tvc.get_name() for tvc in treeview.get_columns()])))

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

taskbody_buffer = TextBuffer()
taskbody_buffer.connect('changed', on_taskbody_changed)
taskbody_buffer.connect_after('insert-text', on_taskbody_typing)
taskbody_buffer.connect('delete-range', on_taskbody_erase)

taskbody_view = gtk.TextView(buffer=taskbody_buffer)
taskbody_view_set_font(Props['field/taskbody/font'] or '')
taskbody_view.set_wrap_mode(getattr(gtk, Props['field/taskbody/wrapmode'] or 'WRAP_WORD'))
taskbody_view.connect('populate-popup', on_taskbody_view_menu)
taskbody_view.connect('key-press-event', on_taskbody_view_keypress)
taskbody_view.connect_after('move-cursor', on_taskbody_view_cursor_moved)
taskbody_view.connect('focus-in-event', on_taskbody_view_focus)

completion_suggestions_box = CompletionSuggestionsBox()

calendar = Calendar()
calendar.connect('mark-added', lambda X, date: taskbody_insert_line(date))
calendar.connect('mark-removed', lambda X, date: taskbody_remove_text_around_cursor(date))

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
add_key_binding(main_win, '<Control>f', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>l', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>s', lambda *X: save_search_query(searchbox.get_text()))
add_key_binding(main_win, '<Mod1>Up', lambda *X: act_tasklist_select_updown(up=True))
add_key_binding(main_win, '<Mod1>Down', lambda *X: act_tasklist_select_updown(up=False))
add_key_binding(main_win, '<Mod1>Left', lambda *X: act_tasklist_select_prevnext(prev=True))
add_key_binding(main_win, '<Mod1>Right', lambda *X: act_tasklist_select_prevnext(prev=False))
add_key_binding(main_win, '<Control>t', lambda *X: taskbody_view.grab_focus())
add_key_binding(main_win, '<Control>n', lambda *X: act_new_task())
add_key_binding(main_win, '<Control><Shift>l', lambda *X: do_layout(LAYOUT[(LAYOUT.index(Props['layout/layout-set'])+1)%len(LAYOUT)]))
add_key_binding(main_win, '<Control><Shift>w', taskbody_view_toggle_wrap)
main_win.connect('delete-event', lambda *X: main_quit())


box_main = gtk.HBox()
main_win.add(box_main)
box_savedsearches = ScrolledWidget(savedsearches_view)
box_tasklist = gtk.VBox()
box_tasklist.pack_start(searchbox, expand=False)
box_tasklist.pack_start(tasklist_top_label, expand=False)
box_tasklist.pack_start(ScrolledWidget(tasklist_view))
box_bottom = gtk.HBox()
box_taskview = gtk.VBox()
box_taskview.pack_start(ScrolledWidget(taskbody_view))
box_taskview.pack_start(completion_suggestions_box, expand=False)
box_auxtools = gtk.VBox()
box_auxtools.pack_start(calendar)

LAYOUT = ['3COL', '2COL1ROW', '1COL2ROW']
def do_layout(layout):
	def unpack(w):
		p = w.get_parent()
		if p is not None:
			p.remove(w)
	
	unpack(paned1)
	unpack(paned2h)
	unpack(paned2v)
	unpack(box_savedsearches)
	unpack(box_tasklist)
	unpack(box_bottom)
	unpack(box_taskview)
	unpack(box_auxtools)
	
	if layout not in LAYOUT:
		sys.stderr.write("Unknown layout '%s', fallback to default\n" % layout)
		layout = '3COL'
	
	if layout == '3COL':
		"""
		+--+--+--+
		|  |  |  |
		|  |  |  |
		|  |  |  |
		+--+--+--+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2h)
		paned2h.pack1(box_tasklist)
		paned2h.pack2(box_taskview)
		box_taskview.pack_start(box_auxtools, expand=False)
	elif layout == '2COL1ROW':
		"""
		+--+---+
		|  |   |
		+--+---+
		|      |
		+------+
		"""
		box_main.pack_start(paned2v)
		paned2v.pack1(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	elif layout == '1COL2ROW':
		"""
		+--+---+
		|  |   |
		|  +---+
		|  |   |
		+--+---+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2v)
		paned2v.pack1(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	
	main_win.show_all()
	calendar.hide()
	completion_suggestions_box.hide()
	Props['layout/layout-set'] = layout


do_layout(Props['layout/layout-set'] or '3COL')
searchbox.grab_focus()
gtk.main()
