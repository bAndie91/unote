#!/usr/bin/env python
# -*- coding: utf-8 -*-

import gtk
import glib
import pango
import time
import re
import glob
import gobject
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory
from datetime import datetime
from dateutil.relativedelta import relativedelta
import xattr
import errno
import traceback
import inotifyx


APPNAME = 'unote'
NOTES_DIR = os.path.expanduser('~/Notes')
NOTES_ARCHIVE_DIR = os.path.expanduser('~/Notes/.Archive')
NOTESFILE_EXCLUDES = ['*~', '*.bak']
# define what counts as a word in task texts and search query text:
taskbody_word_re = r'[#\w-]'


NOTES_DIR = NOTES_DIR.rstrip('/')
NOTES_ARCHIVE_DIR = NOTES_ARCHIVE_DIR.rstrip('/')


def getsizeofrecursive(x):
	size = 0
	if hasattr(x, '__iter__'):
		for y in x: size += getsizeofrecursive(y)
	else:
		size += sys.getsizeof(x)
	return size

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def filenameize(s):
	#s = re.sub(r'(^|/)\.\.(/|$)', '', s)
	s = re.sub(r'/', '⁄', s)
	return s

def find_nonexistent_file(directory, preferred_filename):
	filename = preferred_filename
	n = 1
	while True:
		filepath = os.path.join(directory, filename)
		if not os.path.exists(filepath): break
		n += 1
		filename = '%s (%d)' % (preferred_filename, n)
	return filepath

def str_replace_last(s, f, r):
	pos = s.rfind(f)
	if pos == -1: return s
	return s[0:pos] + r + s[pos+len(f):]

def run_async(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			os.execvp(cmd, args)
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def question(msg, stock_yes=None, stock_no=None, parent=None):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_no is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_NO).hide()
		btn_no = gtk.Button(label=stock_no[0], stock=stock_no[1])
		dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
		btn_no.show()
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = gtk.Button(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget


class Patch(object):
	"""
	License: Public domain (CC0)
	Author: Isaac Turner 2016/12/05
	Source: https://gist.github.com/noporpoise/16e731849eb1231e86d78f9dfeca3abc
	"""
	import difflib
	_no_eol = '\ No newline at end of file'
	_hdr_pat = re.compile('^@@ -(\d+),?(\d+)? \+(\d+),?(\d+)? @@$')

	@classmethod
	def make_patch(selfclass, a, b):
	  """
	  Get unified string diff between two strings. Trims top two lines.
	  Returns empty string if strings are identical.
	  """
	  diffs = selfclass.difflib.unified_diff(a.splitlines(True),b.splitlines(True),n=0)
	  try: X, X = next(diffs),next(diffs)
	  except StopIteration: pass
	  return ''.join([d if d[-1] == '\n' else d+'\n'+selfclass._no_eol+'\n' for d in diffs])
	
	@classmethod
	def apply_patch(selfclass, s, patch, revert=False):
	  """
	  Apply patch to string s to recover newer string.
	  If revert is True, treat s as the newer string, recover older string.
	  """
	  s = s.splitlines(True)
	  p = patch.splitlines(True)
	  t = ''
	  i = sl = 0
	  (midx,sign) = (1,'+') if not revert else (3,'-')
	  while i < len(p) and p[i].startswith(("---","+++")): i += 1 # skip header lines
	  while i < len(p):
	    m = selfclass._hdr_pat.match(p[i])
	    if not m:
	      raise Exception("Bad patch -- regex mismatch [line "+str(i)+"]")
	    l = int(m.group(midx))-1 + (m.group(midx+1) == '0')
	    if sl > l or l > len(s):
	      raise Exception("Bad patch -- bad line num [line "+str(i)+"]")
	    t += ''.join(s[sl:l])
	    sl = l
	    i += 1
	    while i < len(p) and p[i][0] != '@':
	      if i+1 < len(p) and p[i+1][0] == '\\': line = p[i][:-1]; i += 2
	      else: line = p[i]; i += 1
	      if len(line) > 0:
	        if line[0] == sign or line[0] == ' ': t += line[1:]
	        sl += (line[0] != sign)
	  t += ''.join(s[sl:])
	  return t

def get_word_halves(text, pos, word_re=None):
	if word_re is None: word_re = r'\w'
	text_before, text_after = text[0:pos], text[pos:]
	first_half = re.search(word_re + r'*\Z', text_before, re.U).group(0)
	second_half = re.search(r'^'+word_re+r'*', text_after, re.U).group(0)
	return first_half, second_half

def current_word(text, pos, word_re=None):
	return ''.join(get_word_halves(text, pos, word_re))

class TextBuffer(gtk.TextBuffer):
	# at least this many char addition+removal triggers an undo checkpoint:
	undo_checkpoint_threshold = 12
	undo_stack_size_limit = 2*1024*1024
	
	def __init__(self, *args):
		self._eventhandlers = []
		super(self.__class__, self).__init__(*args)
		self.create_tag('headline', scale=pango.SCALE_X_LARGE)
		self.create_tag('strike', strikethrough=True)
		self.create_tag('bold', weight=pango.WEIGHT_ULTRABOLD)
		self.create_tag('code', family='Monospace')
		self.create_tag('link', foreground='blue', underline=pango.UNDERLINE_SINGLE)
		self.create_tag('hidden', invisible=True)
		self.create_tag('alert', foreground='red')
		self._changed_event_handle = super(self.__class__, self).connect('changed', self._undo_checkpoint)
		self.reinit('')
	def reinit(self, text=''):
		self.set_text(text)
		self.undo_stack = []
		self.undo_stack_index = -1
		self.undo_reference_content = text
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return unicode(self.get_slice(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True))
	def get_buffer_halves(self, textiter=None):
		if textiter is None: textiter = self.cursor_iter
		return tuple(map(unicode, (self.get_slice(self.get_start_iter(), textiter, include_hidden_chars=True), self.get_slice(textiter, self.get_end_iter(), include_hidden_chars=True))))
	def get_word_halves(self, textiter, word_re):
		first_half, second_half = self.get_buffer_halves(textiter)
		return get_word_halves(first_half+second_half, len(first_half), word_re)
	def get_word_boundaries(self, textiter, word_re=None):
		text_before, text_after = self.get_buffer_halves(textiter)
		word_first_half, word_second_half = self.get_word_halves(textiter, word_re)
		cursor_offset = len(text_before)
		start_offset = cursor_offset - len(word_first_half)
		end_offset = cursor_offset + len(word_second_half)
		return self.get_iter_at_offset(start_offset), self.get_iter_at_offset(end_offset)
	def get_word(self, textiter, word_re=None):
		return ''.join(self.get_word_halves(textiter, word_re=word_re))
	def get_current_word(self, word_re=None):
		return self.get_word(self.cursor_iter, word_re=word_re)
	@property
	def cursor_iter(self):
		return self.get_iter_at_mark(self.get_insert())
	@property
	def cursor_pos(self):
		#return len(self.get_buffer_halves()[0])
		return self.get_property('cursor-position')
	@cursor_pos.setter
	def cursor_pos(self, pos):
		self.place_cursor(self.get_iter_at_offset(pos))
	def replace_current_word(self, replacement, word_re=None):
		start, end = self.get_word_boundaries(self.cursor_iter, word_re)
		self.delete(start, end)
		self.insert(start, replacement)
	def connect(self, eventname, *args):
		self._eventhandlers.append(super(self.__class__, self).connect(eventname, *args))
	def disconnect(self, eventhandle):
		super(self.__class__, self).disconnect(eventhandle)
		self._eventhandlers.remove(eventhandle)
	def disable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_block(eventhandle)
	def enable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_unblock(eventhandle)
	def get_selected_text(self):
		if self.get_has_selection():
			begin, end = self.get_selection_bounds()
			return self.get_slice(begin, end, include_hidden_chars=True)
		else:
			return ''
	def replace_selected_text(self, replacement):
		if self.get_has_selection():
			self.delete_selection(False, True)
			begin_offset = self.cursor_pos
			end_offset = begin_offset + len(replacement)
			self.insert_at_cursor(replacement)
			self.select_range(self.get_iter_at_offset(begin_offset), self.get_iter_at_offset(end_offset))
	def replace_text(self, start_offset, length, replacement):
		self.delete(self.get_iter_at_offset(start_offset), self.get_iter_at_offset(start_offset+length))
		self.insert(self.get_iter_at_offset(start_offset), replacement)
	def get_current_line_boundaries(self):
		text = self.get_text_all()
		cur = self.cursor_pos
		sol = text.rfind('\n', 0, cur) + 1
		eol = text.find('\n', cur)
		if eol == -1: eol = len(text)
		return sol, eol
	def get_current_line(self):
		sol, eol = map(self.get_iter_at_offset, self.get_current_line_boundaries())
		return self.get_slice(sol, eol, include_hidden_chars=True)
	def apply_tag_by_name(self, tagname, pos1, pos2):
		super(self.__class__, self).apply_tag_by_name(tagname, self.get_iter_at_offset(pos1), self.get_iter_at_offset(pos2))
	def remove_all_tags(self, start=None, end=None):
		if start is None: start = self.get_start_iter()
		if end is None: end = self.get_end_iter()
		super(self.__class__, self).remove_all_tags(start, end)
	def get_tag_by_name(self, tagname):
		return self.get_tag_table().lookup(tagname)
	def _undo_checkpoint(self, *X):
		def chardistance(a, b):
			import difflib
			distance = 0
			for change in difflib.ndiff(a, b):
				if change[0] in ['+', '-']:
					distance += 1
			return distance
		text = self.get_text_all()
		if chardistance(self.undo_reference_content, text) > self.undo_checkpoint_threshold:
			self.create_undo_checkpoint()
	def create_undo_checkpoint(self):
		text = self.get_text_all()
		patch = Patch.make_patch(self.undo_reference_content, text)
		if patch != '':
			del self.undo_stack[self.undo_stack_index+1:]
			self.undo_stack.append((patch, self.cursor_pos))
			self.undo_stack_index += 1
			self.undo_reference_content = text
			while getsizeofrecursive(self.undo_stack) > self.undo_stack_size_limit:
				del self.undo_stack[0]
				self.undo_stack_index -= 1
	def undo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index >= 0:
			patch, pos = self.undo_stack[self.undo_stack_index]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=True)
			self.handler_block(self._changed_event_handle)
			self.set_text(replacement)
			self.handler_unblock(self._changed_event_handle)
			self.cursor_pos = pos
			self.undo_stack_index -= 1
			self.undo_reference_content = replacement
	def redo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index < len(self.undo_stack) - 1:
			patch, pos = self.undo_stack[self.undo_stack_index + 1]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=False)
			self.handler_block(self._changed_event_handle)
			self.set_text(replacement)
			self.handler_unblock(self._changed_event_handle)
			self.cursor_pos = pos
			self.undo_stack_index += 1
			self.undo_reference_content = replacement

class CompletionSuggestionsBox(gtk.TextView):
	def __init__(self, *args):
		self._all_items = []
		self._filterer_word = ''
		self._shown_items = []
		self._suggestion_index = -1
		super(self.__class__, self).__init__(*args)
		self.set_wrap_mode(gtk.WRAP_WORD)
		self.set_editable(False)
		self.get_buffer().create_tag('active_suggestion', background='yellow', weight=pango.WEIGHT_BOLD)
		self.get_buffer().create_tag('inactive_suggestion')
		# style
		bgcolor = gtk.gdk.Color('lightgrey')
		self.modify_base(gtk.STATE_NORMAL, bgcolor)
	def filter_for(self, word):
		last_suggestion = self.get_current_suggestion()
		self._filterer_word = word
		self._shown_items = filter(lambda item: self._filter_func(word, item), self._all_items)
		idx = -1
		if last_suggestion is not None:
			try: idx = self._shown_items.index(last_suggestion)
			except ValueError: pass
		self.set_suggestion_index(idx)
	@staticmethod
	def _filter_func(query, option):
		if query == option: return False
		query_norm = re.sub(r'[^\w-]', '', query, flags=re.I|re.U)
		return option.find(query_norm) > -1
	def next_suggestion(self):
		idx = self._suggestion_index + 1
		if idx >= len(self._shown_items): idx = 0
		self.set_suggestion_index(idx)
		return self.get_current_suggestion()
	def previous_suggestion(self):
		idx = self._suggestion_index - 1
		if idx < 0: idx = len(self._shown_items)-1
		self.set_suggestion_index(idx)
		return self.get_current_suggestion()
	def get_current_suggestion(self):
		if len(self._shown_items) == 0: return None
		return self._shown_items[self._suggestion_index]
	def set_suggestion_index(self, idx=-1):
		textbuffer = self.get_buffer()
		textbuffer.set_text('')
		for i, item in enumerate(self._shown_items):
			tagname = 'active_suggestion' if i == idx else 'inactive_suggestion'
			textbuffer.insert_with_tags_by_name(textbuffer.get_end_iter(), item, tagname)
			textbuffer.insert(textbuffer.get_end_iter(), ' ')
		self._suggestion_index = idx
	def set_items(self, items):
		self._all_items = items[:]
		self.filter_for(self._filterer_word)

class TreeStore(gtk.TreeStore):
	__gsignals__ = {
		'changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
	}
	def __init__(self, *columns):
		self.column = {}
		self.reader = {}
		self.empty = []
		types = []
		n = 0
		for col_name, col_type in columns:
			empty_value = None
			if col_type == unicode:
				col_type = str
				self.reader[n] = self.to_unicode
			if col_type == str:
				empty_value = ''
			elif col_type in [int, float]:
				empty_value = 0
			self.empty.append(empty_value)
			types.append(col_type)
			self.column[col_name] = n
			n += 1
		super(self.__class__, self).__init__(*types)
		for event in 'row-changed', 'row-deleted', 'row-inserted', 'rows-reordered':
			self.connect_after(event, self._on_change, event)
	def _on_change(self, *X):
		self.emit('changed')
	@staticmethod
	def to_unicode(s):
		if s is None: return None
		return unicode(s)
	def get_column_num(self, col_name):
		if isinstance(col_name, int): return col_name
		return self.column[col_name]
	def get(self, row, *columns):
		if type(row) == tuple:
			row = self.get_iter(row)  # tree iterator path was given
		if len(columns) == 0:
			return tuple()
		columns = list(columns)
		for i, col in enumerate(columns):
			columns[i] = self.get_column_num(col)
		answer = super(self.__class__, self).get(row, *columns)
		answer = list(answer)
		for i, col in enumerate(columns):
			if self.reader.has_key(col):
				answer[i] = self.reader[col](answer[i])
		answer = tuple(answer)
		return answer
	class TreeModelRow(object):
		def __init__(self, treemodelrow):
			self.real_treemodelrow = treemodelrow
			for attr in dir(treemodelrow):
				if attr not in ['__getitem__', 'iterchildren', '__class__']:
					try: setattr(self, attr, getattr(treemodelrow, attr))
					except AttributeError: pass
		def __getitem__(self, item):
			return self.model.get(self.iter, item)[0]
		def __setitem__(self, item, value):
			item = self.model.get_column_num(item)
			self.real_treemodelrow[item] = value
		def __len__(self):
			return self.real_treemodelrow.__len__()
	def __getitem__(self, item):
		answer = super(self.__class__, self).__getitem__(item)
		return self.TreeModelRow(answer)
	def append(self, parent, row):
		if type(row) == dict:
			cols = row
			row = self.empty[:]
			for col_name, value in cols.iteritems():
				row[self.get_column_num(col_name)] = value
		return super(self.__class__, self).append(parent, row)
	def set(self, treeiter, *itempairs):
		if len(itempairs) == 0: return
		if type(itempairs[0]) == dict:
			cols = itempairs[0]
			itempairs = []
			for col_name, value in cols.iteritems():
				itempairs.extend([self.get_column_num(col_name), value])
		super(self.__class__, self).set(treeiter, *itempairs)
	def get_cells_by_column(self, col_name):
		row = self.get_iter_root()
		while row is not None:
			yield self[row][col_name]
			row = successor_iter(self, row)
	def iterate_columns(self, *columns):
		row = self.get_iter_root()
		while row is not None:
			answer = [row]
			answer.extend(self.get(row, *columns))
			yield answer
			row = successor_iter(self, row)
	def rowpath_by_filtered_row(self, filtered_model, filtered_row, key_column):
		"""This method takes a TreeModel originated by the filter_new() method of this TreeModel instance,
		and a row of the filtering TreeModel (either path or iter) and column (name or number),
		and returns the path of row in this TreeModel instance which matches to the asked row 
		based on the same data in their key columns.
		It basically makes reference between the filtered and the unfiltered TreeModel."""
		key_column = self.get_column_num(key_column)
		key = filtered_model[filtered_row][key_column]
		def findrow(model, treepath, treeiter, data):
			if model[treeiter][key_column] == key:
				data['found'] = treepath
				return True
			return False
		data = {'found': None, 'key_column': key_column, 'key': key}
		self.foreach(findrow, data)
		if data['found'] is None:
			raise KeyError()  # can not imagine how could it happen
		else:
			return data['found']

class TreeView(gtk.TreeView):
	__gsignals__ = {
		'menu-popup': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT)),
	}
	def __init__(self, *args, **kvargs):
		super(self.__class__, self).__init__(*args, **kvargs)
		self.connect('button-press-event', self._on_button_click)
	def _on_button_click(self, widget, event):
		if event.button == 3:
			x, y = int(event.x), int(event.y)
			t = self.get_path_at_pos(x, y)
			if t is not None:
				treepath, tv_col, cell_x, cell_y = t
			else:
				treepath, tv_col, cell_x, cell_y = None, None, None, None
			popup_menu = gtk.Menu()
			if not self.emit('menu-popup', popup_menu, treepath, tv_col, cell_x, cell_y):
				# event is not handled by any handlers, so do it ourself
				if popup_menu.get_children():
					popup_menu.show_all()
					popup_menu.popup(None, None, None, event.button, event.time)
			return True

class Calendar(gtk.Calendar):
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'mark-added': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
		'mark-removed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
	}
	date_format = '%04d-%02d-%02d'
	def __init__(self):
		self._marks = {}
		self.selected_day = (0, 0, 0)
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		# create popup menu
		self.popup_menu = gtk.Menu()
		mi = gtk.MenuItem("Go Today")
		mi.connect('activate', self.gotoday)
		self.popup_menu.append(mi)
		self.popup_menu.show_all()
		# set initial state
		self.gotoday()
		self.connect('key-release-event', self.on_key_press_release)
		self.connect('button-press-event', self.on_mouse_click)
		self.connect('button-release-event', self.on_mouse_clicked)
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	def on_mouse_click(self, widget, event):
		if event.button == 3:
			self.popup_menu.popup(None, None, None, event.button, event.time)
			return True  # eat the event
	def on_mouse_clicked(self, widget, event):
		if event.button == 1:
			if self.get_date()[2] != 0:
				self.on_user_select_day()
				return False  # let the event pass
	def on_key_press_release(self, widget, event):
		c_year, c_month, c_day = self.get_date()
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			if c_day == self.selected_day[2]:
				self.select_day(0)
				self.selected_day = (0, 0, 0)
			else:
				self.on_user_select_day()
		elif event.keyval in [gtk.gdk.keyval_from_name('Enter'), gtk.gdk.keyval_from_name('Return')]:
			s_year, s_month, s_day = self.selected_day[:]
			space_key_event = event.copy()
			space_key_event.keyval = int(gtk.gdk.keyval_from_name('space'))
			self.emit('key-press-event', space_key_event)
			self.emit('key-release-event', space_key_event)
			m_year, m_month, m_day = self.get_date()
			if m_day == 0:
				m_year, m_month, m_day = s_year, s_month, s_day
			self.do_mark(m_year, m_month, m_day)
			self.selected_day = (s_year, s_month, s_day)
			self.on_paging()
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Up'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=-1)
			self.select_month(date.month - 1, date.year)
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Down'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=+1)
			self.select_month(date.month - 1, date.year)
	def gotoday(self, *X):
		now = time.localtime()
		self.select_month(now.tm_mon - 1, now.tm_year)
		self.select_day(now.tm_mday)
		self.selected_day = (now.tm_year, now.tm_mon, now.tm_mday)
		self.on_paging()
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in self._marks.keys():
			response.append(date_format % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		self.do_mark(c_year, c_month, c_day)
	def do_mark(self, c_year, c_month, c_day):
		was_marked = False
		for year, month, day in self._marks.keys():
			if year == c_year and month == c_month and c_day == day:
				was_marked = True
				del self._marks[(year, month, day)]
		if was_marked:
			self.emit('mark-removed', self.date_format % (c_year, c_month, c_day))
		else:
			self._marks[(c_year, c_month, c_day)] = True
			self.emit('mark-added', self.date_format % (c_year, c_month, c_day))
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)
		if c_year == self.selected_day[0] and c_month == self.selected_day[1]:
			self.select_day(self.selected_day[2])
	def on_user_select_day(self, *X):
		self.selected_day = self.get_date()

class ActionStockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None, action=None, use_underline=False):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)
			self.set_use_underline(use_underline)
		if action is not None:
			self.connect('activate', action)

def add_treeview_columns(treeview, columns):
	for col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_title(col_title)
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		treeview.append_column(tvc)
		tvc.set_resizable(True)
		tvc.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
		width = Props['layout/column/%s/width'%col_title]
		if width is not None:
			tvc.set_fixed_width(int(width))
		else:
			tvc.set_fixed_width(100)
		tvc.connect('notify::width', lambda widget, prop: Props.__setitem__('layout/column/%s/width'%widget.get_title(), widget.get_width()))

def main_quit():
	save_position()
	# execute outstanding timers
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()
	# load last opened task
	for treeiter, task_file in tasklist.iterate_columns('file'):
		if task_file == Props['history/last/opened-task/path']:
			tasklist_selection.select_path(tasklist.get_path(treeiter))

class PropertyTree(dict):
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.savedprops = {}
		self.write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.iteritems():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def on_notes_dir_changed(fd, Xcondition):
	inotifyx.get_events(fd)
	load_tasklist()
	return True

def load_tasks():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(NOTES_DIR), topdown=True, onerror=None, followlinks=True):
		for idx, dirname in enumerate(dirnames):
			if dirname.startswith('.'):
				# don't descent into hidden directories
				del dirnames[idx]
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in NOTESFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			mtime = os.stat(filepath).st_mtime
			with open(filepath, 'r') as f:
				text = f.read()
				text = unicode(text)
				yield text, filepath, mtime

def get_tags(text):
	return re.findall(r'(?:^|\s|,)(#[\w-]+)', text, re.I|re.U)

def update_task_in_list(treestore, treeiter, task_text=None, task_file=None, task_mtime=None):
	row = {}
	if task_text is not None:
		preview = task_text
		charshift = 0
		for s, e, hideranges in find_markup_positions(preview, 'bold'):
			for s, e in hideranges:
				preview = preview[0:s+charshift] + preview[e+charshift:]
				charshift -= e - s
		preview += '\n'
		head, body = preview.split('\n', 1)
		body = re.sub(r'\n+', ' ', body)
		body = body[0:255] + ('…' if len(body)>255 else '')
		row['headline_markup'] = '%s <span foreground="grey">%s</span>' % (glib.markup_escape_text(head), glib.markup_escape_text(body))
		row['raw_text'] = task_text
	if task_file is not None:
		row['file'] = task_file
	if task_mtime is not None:
		row['updated'] = time.strftime('%F %H:%M', time.localtime(task_mtime))
	treestore.set(treeiter, row)

def load_tasklist():
	tasklist.clear()
	for task_text, task_file, task_mtime in load_tasks():
		treeiter = tasklist.append(None, {})
		update_task_in_list(tasklist, treeiter, task_text, task_file, task_mtime)

def on_tasklist_changed(*X):
	timer_once(0.2, process_tasklist)

def process_tasklist():
	AllTags.clear()
	def process_tasklist_taskitem(model, path, treeiter):
		task_text = model[path]['raw_text']
		for tag in get_tags(task_text):
			AllTags[tag] = AllTags.get(tag, 0) + 1
	tasklist.foreach(process_tasklist_taskitem)
	completion_suggestions_box.set_items(AllTags.keys())

def save_position():
	filepath = taskbody_view.get_data('loaded-task-file')
	if filepath is not None:
		pos = taskbody_buffer.cursor_pos
		try:
			xattr.setxattr(filepath, 'user.textedit.cursor_position', str(pos))
		except IOError:
			traceback.print_exc()

def load_taskbody(text):
	save_position()
	taskbody_buffer.disable_events()
	taskbody_buffer.reinit(text)
	taskbody_buffer.enable_events()
	parse_taskbody(text)
	calendar.gotoday()

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[m[0:3].lower()]
	except KeyError: pass
	return m

def find_markup_positions(text, markupname):
	def find_coderanges(text):
		# lines between 2 set of triple backticks, and
		# words embraced by backticks
		# (allow to escape first backtick: r'(?<!\\)(?:\\\\)*`(.*?(?<!\\)(?:\\\\)*)`')
		for regex in r'^```[^\n]*\n(.*?)(?<=\n)```', r'(?<!\w)`(.*?(?<!\\)(?:\\\\)*)`(?!\w)':
			for match in re.finditer(regex, text, re.S|re.M):
				yield match.start(1), match.end(1), []
	if markupname == 'headline':
		first_eol = text.find('\n')
		if first_eol > -1:
			yield 0, first_eol, []
		else:
			yield 0, len(text), []
	elif markupname == 'link':
		for match in re.finditer(r'\b([a-z+-]+://[^\s]+)', text, re.I):
			yield match.start(0), match.end(0), []
	elif markupname == 'strike':
		for match in re.finditer(ur'^\s*(?:-\s*)?(.+?)(\s+(DONE|WONTFIX|OBSOLETED)|\s*(✓|✔|✗|✘|\[(DONE|WONTFIX|OBSOLETED)\]))', text, re.U|re.M):
			yield match.start(1), match.end(1), []
	elif markupname in ['bold', 'alert']:
		coderanges = [(s, e) for s, e, h in find_coderanges(text)]
		if markupname == 'bold':
			# words embraced in asterisks, optionally surrounded by brackets or whitespace but nothing else
			for match in re.finditer(r'(^|[\s\(\[\{\<])\*(?!\s|\*)(.+?)(?<!\s|\*)\*(?=[\s\)\]\}\>]|$)', text):
				start, end = match.start(2), match.end(2)
				if all([end < s or start > e for s, e in coderanges]):
					yield start, end, [(start-1, start), (end, end+1)]
		elif markupname == 'alert':
			# a line ending in double exclamation marks, and literal string "<!>"
			for regex in r'^\s*(?:-\s*)?(.+!!)\s*$', r'(<!>)':
				for match in re.finditer(regex, text, re.M):
					start, end = match.start(1), match.end(1)
					if all([end < s or start > e for s, e in coderanges]):
						yield start, end, []
	elif markupname == 'code':
		for start, end, hideranges in find_coderanges(text):
			yield start, end, hideranges
	else:
		raise

def parse_taskbody(text):
	# style and format text
	taskbody_buffer.remove_all_tags()
	for markupname in ['headline', 'link', 'strike', 'bold', 'code', 'alert']:
		for start, end, hideranges in find_markup_positions(text, markupname):
			taskbody_buffer.apply_tag_by_name(markupname, start, end)
			for start, end in hideranges:
				taskbody_buffer.apply_tag_by_name('hidden', start, end)
	
	# find date strings and show them in calendar
	calendar_marks = []
	re_months = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
	for y, m, d in re.findall(r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + re_months + r')-(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + re_months + r')(?:-|\s+)(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	if calendar_marks or re.search(r'\b(date|due):', text, re.I):
		if not calendar.get_visible():
			calendar.gotoday()
		calendar.show()
	else:
		calendar.hide()

def on_tasklist_selection_change(selection):
	Xmodel, iterpaths = selection.get_selected_rows()
	if len(iterpaths) == 0:
		return
	iterpath = iterpaths[0]
	treeiter = tasklist.get_iter(tasklist.rowpath_by_filtered_row(tasklist_filtered, iterpath, key_column='file'))
	loaded_task_file = taskbody_view.get_data('loaded-task-file')
	if loaded_task_file is not None and loaded_task_file == tasklist[treeiter]['file']:
		return
	task_text = tasklist[treeiter]['raw_text']
	load_taskbody(task_text)
	task_file = tasklist[treeiter]['file']
	taskbody_view.set_data('loaded-task-file', task_file)
	Props['history/last/opened-task/path'] = task_file
	# restore cursor position:
	try:
		cursor_pos = xattr.getxattr(tasklist[treeiter]['file'], 'user.textedit.cursor_position')
	except IOError as e:
		if e.errno == errno.ENODATA: pass
		else: raise
	else:
		if cursor_pos is not None:
			taskbody_buffer.cursor_pos = int(cursor_pos)
			act_taskbody_view_scroll_to_cursor()

def timer_once(sec, func, func_args=(), reschedule=True):
	iden = func.__name__
	if Timers.has_key(iden):
		if reschedule:
			glib.source_remove(Timers[iden]['handle'])
			del Timers[iden]
		else:
			return
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.4, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def on_searchbox_icon_clicked(entry, icon_pos, event):
	if icon_pos == 1:
		entry.set_text('')

def successor_iter(model, predecessor):
	"""return the next "heir" in line of succession metaphorically speaking.
	i.e. the first child of the node if there is any, otherwise its next sibling node,
	otherwise its parent node's next sibling."""
	if model.iter_has_child(predecessor):
		return model.iter_nth_child(predecessor, 0)
	else:
		successor = model.iter_next(predecessor)
		if successor is None:
			while True:
				parent = model.iter_parent(predecessor)
				if parent is None: return None
				uncle = model.iter_next(parent)
				if uncle is not None: return uncle
				predecessor = parent
			return None
		return successor

def on_searchbox_keypress(widget, event):
	keys = KeyDetector(event)
	mod_up = keys.up and (keys.alt or keys.shift)
	mod_down = keys.down and (keys.alt or keys.shift)
	if mod_up or mod_down:
		Xmodel, s_rows = tasklist_selection.get_selected_rows()
		if len(s_rows) == 0:
			c_iter = None
			s_iter = tasklist_filtered.get_iter_root()
		else:
			c_iter = tasklist_filtered.get_iter(s_rows[0 if mod_up else -1])
		if c_iter is not None:
			if mod_down:
				s_iter = successor_iter(tasklist_filtered, c_iter) or c_iter
			elif mod_up:
				predecessor = tasklist_filtered.get_iter_root()
				while predecessor is not None:
					successor = successor_iter(tasklist_filtered, predecessor)
					if successor is None:
						s_iter = tasklist_filtered.get_iter_root()
						break
					if tasklist_filtered.get_path(successor) == tasklist_filtered.get_path(c_iter):
						s_iter = predecessor
						break
					predecessor = successor
		if s_iter is not None:
			tasklist_selection.unselect_all()
			tasklist_selection.select_iter(s_iter)
	if keys.control and keys.S:
		save_search_query(searchbox.get_text())
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			old = searchbox.get_text()
			pos = searchbox.get_property('cursor-position')
			first_half, second_half = get_word_halves(old, pos, word_re=taskbody_word_re)
			new_pre = old[0:pos-len(first_half)] + word + ' '
			new_post = old[pos+len(second_half):]
			searchbox.set_text(new_pre + new_post)
			searchbox.set_position(len(new_pre))
		tab_completion_handled = handle_tab_completion(event, complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled

def on_searchbox_keypressed(widget, event):
	c_word = current_word(searchbox.get_text(), searchbox.get_property('cursor-position'), word_re=taskbody_word_re)
	if c_word.startswith('#'):
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(c_word)
	else:
		completion_suggestions_box.hide()

def save_search_query(query):
	query = query.strip()
	if query != '' and query not in savedsearches.get_cells_by_column('query'):
		savedsearches.append(None, [query])

def on_savedsearches_changed(*X):
	Props['field/quicksearch/list'] = '\n'.join(filter(lambda x: x is not None, savedsearches.get_cells_by_column('query')))

def on_savedsearches_menu(treeview, popup_menu, treepath, tv_col, cell_x, cell_y):
	if treepath is not None:
		savedquery = savedsearches[treepath]['query']
		popup_menu.append(ActionStockMenuItem(label=_("Remove '%s'")%savedquery, stock_id=gtk.STOCK_REMOVE, action=lambda *X: savedsearches.remove(savedsearches.get_iter(treepath))))

def on_savedsearches_selection(selection):
	Xmodel, iterpaths = selection.get_selected_rows()
	if len(iterpaths) > 0:
		new_query = ' '.join([savedsearches[iterpath]['query'] for iterpath in iterpaths])
		searchbox.set_text(new_query)

def on_tasklist_menu(treeview, popup_menu, treepath, tv_col, cell_x, cell_y):
	if treepath is not None:
		popup_menu.append(ActionStockMenuItem(label=_("Done"), stock_id=gtk.STOCK_APPLY, action=lambda *X: act_task_done(treepath)))
		popup_menu.append(ActionStockMenuItem(label=_("Delete…"), stock_id=gtk.STOCK_DELETE, action=lambda *X: act_task_delete(treepath)))

def act_task_done(treefilter_treepath):
	rowpath = tasklist.rowpath_by_filtered_row(tasklist_filtered, treefilter_treepath, key_column='file')
	filepath = tasklist[rowpath]['file']
	subpath = filepath[len(NOTES_DIR)+1:]
	subdir, subfile = os.path.split(subpath)
	newpath = find_nonexistent_file(os.path.join(NOTES_ARCHIVE_DIR, subdir), subfile)
	mkdir(os.path.dirname(newpath))
	act_new_task()
	os.rename(filepath, newpath)

def act_task_delete(treefilter_treepath):
	rowpath = tasklist.rowpath_by_filtered_row(tasklist_filtered, treefilter_treepath, key_column='file')
	filepath = tasklist[rowpath]['file']
	if question(_("Really delete?")+'\n<tt>'+glib.markup_escape_text(filepath)+'</tt>', stock_yes=(None, gtk.STOCK_DELETE), stock_no=(None, gtk.STOCK_CANCEL), parent=main_win):
		act_new_task()
		os.remove(filepath)

def filter_tasklist():
	tasklist_filtered.refilter()

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	if query == '':
		return True
	task_text = model[treeiter]['raw_text']
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = task_text.find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def get_tasklist_treeiter_by_file(q_file):
	treeiter = None
	for c_iter, c_file in tasklist.iterate_columns('file'):
		if c_file == q_file:
			return c_iter
	raise KeyError(_("No row with file=='%s'") % q_file)

def save_task():
	loaded_task_file = taskbody_view.get_data('loaded-task-file')
	if loaded_task_file is not None:
		treeiter = get_tasklist_treeiter_by_file(loaded_task_file)
		text = tasklist[treeiter]['raw_text']
		with open(loaded_task_file, 'w') as f:
			f.write(text)

def on_taskbody_changed(*X):
	text = taskbody_buffer.get_text_all()
	# re-parse
	parse_taskbody(text)
	# represent task text in the task list
	loaded_task_file = taskbody_view.get_data('loaded-task-file')
	if loaded_task_file is None:
		# don't save new task until at least one line is entered,
		# and generate file name from the first line
		m = re.search(r'^\s*(.+?)\n', text)
		if not m: return
		first_line = m.group(1)
		filepath = find_nonexistent_file(NOTES_DIR, filenameize(first_line) + '.txt')
		open(filepath, 'w').write(text)
		taskbody_view.set_data('loaded-task-file', filepath)
	else:
		treeiter = get_tasklist_treeiter_by_file(loaded_task_file)
		update_task_in_list(tasklist, treeiter, task_text=text, task_mtime=time.time())
		# schedule save
		timer_once(5.0, save_task, [], reschedule=False)

def on_taskbody_typing(textbuffer, textiter, typedtext, length):
	first_half, second_half = textbuffer.get_word_halves(textiter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def on_taskbody_erase(textbuffer, startiter, enditer):
	first_half = textbuffer.get_word_halves(startiter, word_re=taskbody_word_re)[0]
	second_half = textbuffer.get_word_halves(enditer, word_re=taskbody_word_re)[1]
	c_word = first_half+second_half
	act_taskbody_word(c_word, len(first_half))

def act_taskbody_word(word, pos):
	if word.startswith('#') and pos>0:
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(word)
	else:
		completion_suggestions_box.hide()

def act_change_font(*X):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(main_win)
	dlg.set_modal(True)
	dlg.set_font_name(Props['field/taskbody/font'] or textview_get_current_font(taskbody_view)['name'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['field/taskbody/font'] = font_name
		taskbody_view_set_font(font_name)
	dlg.destroy()

def textview_get_current_font(textview):
	pctx = textview.get_pango_context()
	fdsc = pctx.get_font_description()
	return {'name': fdsc.to_string(), 'size': int(fdsc.get_size()/pango.SCALE)}

def taskbody_view_set_font(fontname):
	taskbody_view.modify_font(pango.FontDescription(fontname))
	fontsize = textview_get_current_font(taskbody_view)['size']
	head_tag = taskbody_buffer.get_tag_by_name('headline')
	head_tag.set_property('pixels-below-lines', int(fontsize * 0.8))

def taskbody_view_toggle_wrap(*X):
	wrap_mode = 'WRAP_NONE' if taskbody_view.get_wrap_mode() != gtk.WRAP_NONE else 'WRAP_WORD'
	taskbody_view.set_wrap_mode(getattr(gtk, wrap_mode))
	Props['field/taskbody/wrapmode'] = wrap_mode

def on_taskbody_view_menu(Xtextview, menu):
	pos = 0
	mi = ActionStockMenuItem(label=_("Default Font…"), stock_id=gtk.STOCK_SELECT_FONT, action=act_change_font)
	menu.insert(mi, pos)
	pos += 1
	mi = gtk.CheckMenuItem(label=_("Wrap Lines"))
	mi.set_active(taskbody_view.get_wrap_mode() != gtk.WRAP_NONE)
	mi.connect('toggled', taskbody_view_toggle_wrap)
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	menu.show_all()

class KeyDetector(object):
	def __init__(self, event):
		self.tab = False
		self.backtab = False
		self.control = event.state & gtk.gdk.CONTROL_MASK != 0
		self.shift = event.state & gtk.gdk.SHIFT_MASK != 0
		self.alt = event.state & gtk.gdk.MOD1_MASK != 0
		if not self.control and not self.alt:
			self.tab = event.keyval == gtk.gdk.keyval_from_name('Tab') and not self.shift
			self.backtab = (event.keyval == gtk.gdk.keyval_from_name('Tab') and self.shift) or event.keyval == gtk.gdk.keyval_from_name('ISO_Left_Tab')
		self.enter = event.keyval in [gtk.gdk.keyval_from_name('Return'), gtk.gdk.keyval_from_name('Enter')]
		self.escape = event.keyval == gtk.gdk.keyval_from_name('Escape')
		self.up = event.keyval == gtk.gdk.keyval_from_name('Up')
		self.down = event.keyval == gtk.gdk.keyval_from_name('Down')
		for letter in map(chr, range(ord('a'), ord('z')+1)):
			setattr(self, letter.upper(), event.keyval == gtk.gdk.keyval_from_name(letter))

def handle_tab_completion(event, callback):
	keys = KeyDetector(event)
	if keys.tab:
		completion_suggestions_box.next_suggestion()
		return True  # prevent event propagation
	elif keys.backtab:
		completion_suggestions_box.previous_suggestion()
		return True
	elif keys.control and keys.enter:
		suggestion = completion_suggestions_box.get_current_suggestion()
		if suggestion is not None:
			callback(suggestion)
			completion_suggestions_box.hide()
			return True
	return None

def on_taskbody_view_keypress(widget, event):
	keys = KeyDetector(event)
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			taskbody_buffer.replace_current_word(word+' ', word_re=taskbody_word_re)
		tab_completion_handled = handle_tab_completion(event, callback=complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled
	
	if keys.escape:
		completion_suggestions_box.hide()
		return True
	if keys.tab or keys.backtab:
		selected_text = taskbody_buffer.get_selected_text()
		if selected_text != '':
			if keys.tab:
				selected_text = re.sub(r'^(?=.)', '\t', selected_text, flags=re.M)
			elif keys.backtab:
				selected_text = re.sub(r'^\t', '', selected_text, flags=re.M)
			taskbody_buffer.replace_selected_text(selected_text)
		else:
			if keys.tab:
				return False
			elif keys.backtab:
				line = taskbody_buffer.get_current_line()
				if line.startswith('\t'):
					sol, Xeol = taskbody_buffer.get_current_line_boundaries()
					taskbody_buffer.delete(taskbody_buffer.get_iter_at_offset(sol), taskbody_buffer.get_iter_at_offset(sol+1))
		return True
	if keys.control:
		if keys.enter:
			pos = taskbody_buffer.cursor_pos
			for start, end in find_markup_positions(taskbody_buffer.get_text_all(), 'link'):
				if start <= pos < end:
					link = taskbody_buffer.get_text_all()[start:end]
					run_async('xdg-open', [link])
					return True
		elif keys.B:
			s = taskbody_buffer.get_selected_text()
			if s.startswith('*') and s.endswith('*') and len(s)>2:
				s = s[1:-1]
			else:
				s = '*' + s + '*'
			taskbody_buffer.replace_selected_text(s)
			return True
		elif keys.Y or (keys.Z and keys.shift):
			taskbody_buffer.redo()
			act_taskbody_view_scroll_to_cursor()
			return True
		elif keys.Z:
			taskbody_buffer.undo()
			act_taskbody_view_scroll_to_cursor()
			return True

def act_taskbody_view_scroll_to_cursor():
	taskbody_view.scroll_to_mark(taskbody_buffer.get_insert(), within_margin=0.33)

def on_taskbody_view_cursor_moved(Xtextview, Xstep_size, Xcount, Xextend_selection):
	first_half, second_half = taskbody_buffer.get_word_halves(taskbody_buffer.cursor_iter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def taskbody_insert_line(s):
	pre, post = taskbody_buffer.get_buffer_halves()
	if pre[-1] != '\n': s = '\n' + s
	if post == '' or post[0] != '\n': s = s + '\n'
	taskbody_buffer.insert_at_cursor(s)

def taskbody_remove_text_around_cursor(s):
	"""removes first occurrance of s from taskbody_buffer before the cursor
	or after the cursor, whichever is the nearest.
	removes newline if s is a complete line."""
	pre, post = taskbody_buffer.get_buffer_halves()
	pre_pos = (pre+post).rfind(s, 0, len(pre)+len(s)-2)
	post_pos = post.find(s)
	if pre_pos > -1 and post_pos > -1:
		pre_distance = len(pre) - pre_pos - len(s)
		post_distance = post_pos
		if post_distance < pre_distance:
			remove_from_pos = len(pre)+post_pos
		else:
			remove_from_pos = pre_pos
	elif post_pos > -1:
		remove_from_pos = len(pre)+post_pos
	elif pre_pos > -1:
		remove_from_pos = pre_pos
	else:
		return False
	remove_length = len(s)
	if (remove_from_pos > 0 and (pre+post)[remove_from_pos-1] == '\n' or remove_from_pos == 0) and remove_from_pos+len(s) < len(pre+post) and (pre+post)[remove_from_pos+len(s)] == '\n':
		remove_length = remove_length + 1
	taskbody_buffer.replace_text(remove_from_pos, remove_length, '')

def act_new_task():
	save_position()
	tasklist_selection.unselect_all()
	taskbody_view.set_data('loaded-task-file', None)
	taskbody_buffer.reinit("")
	taskbody_view.grab_focus()


Timers = {}
Props = PropertyTree()
AllTags = {}

main_win = gtk.Window()
paned1 = gtk.HPaned()
paned2h = gtk.HPaned()
paned2v = gtk.VPaned()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2h.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass
try: paned2v.set_position(*map(int, getprops('layout/panel/tasklist/height')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2h.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))
paned2v.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/height', paned.get_position())))

savedsearches = TreeStore(('query', unicode))
for query in filter(lambda query: query != '', map(lambda query: query.strip(), (Props['field/quicksearch/list'] or '').split('\n'))):
	savedsearches.append(None, {'query': query})
savedsearches.connect('changed', on_savedsearches_changed)
savedsearches_view = TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [(_("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)
savedsearches_view.connect('menu-popup', on_savedsearches_menu)

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)
savedsearches_selection.connect('changed', on_savedsearches_selection)

searchbox = gtk.Entry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.set_icon_from_stock(1, gtk.STOCK_CLEAR)
searchbox.connect('changed', on_searchbox_change)
searchbox.connect('key-press-event', on_searchbox_keypress)
searchbox.connect('key-release-event', on_searchbox_keypressed)
searchbox.connect('icon-release', on_searchbox_icon_clicked)

directory_watcher = inotifyx.init()
inotifyx.add_watch(directory_watcher, NOTES_DIR, inotifyx.IN_MODIFY | inotifyx.IN_CREATE | inotifyx.IN_DELETE | inotifyx.IN_MOVE)
glib.io_add_watch(directory_watcher, glib.IO_IN|glib.IO_OUT, on_notes_dir_changed)

tasklist = TreeStore(('headline_markup', unicode), ('raw_text', unicode), ('file', unicode), ('updated', str), ('due', str))
tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)
tasklist.connect('row-changed', on_tasklist_changed)
tasklist.connect('row-deleted', on_tasklist_changed)
tasklist.connect('row-inserted', on_tasklist_changed)

tasklist_view = TreeView(tasklist_filtered)
add_treeview_columns(tasklist_view, [
	(_("Task"), 'markup', tasklist.get_column_num('headline_markup')),
	(_("Updated"), 'text', tasklist.get_column_num('updated')),
	(_("Due"), 'text', tasklist.get_column_num('due')),
])
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)
tasklist_view.connect('menu-popup', on_tasklist_menu)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

taskbody_buffer = TextBuffer()
taskbody_buffer.connect('changed', on_taskbody_changed)
taskbody_buffer.connect_after('insert-text', on_taskbody_typing)
taskbody_buffer.connect('delete-range', on_taskbody_erase)

taskbody_view = gtk.TextView(buffer=taskbody_buffer)
taskbody_view_set_font(Props['field/taskbody/font'] or '')
taskbody_view.set_wrap_mode(getattr(gtk, Props['field/taskbody/wrapmode'] or 'WRAP_WORD'))
taskbody_view.connect('populate-popup', on_taskbody_view_menu)
taskbody_view.connect('key-press-event', on_taskbody_view_keypress)
taskbody_view.connect_after('move-cursor', on_taskbody_view_cursor_moved)

completion_suggestions_box = CompletionSuggestionsBox()

calendar = Calendar()
calendar.connect('mark-added', lambda X, date: taskbody_insert_line(date))
calendar.connect('mark-removed', lambda X, date: taskbody_remove_text_around_cursor(date))

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
add_key_binding(main_win, '<Control>f', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>t', lambda *X: taskbody_view.grab_focus())
add_key_binding(main_win, '<Control>n', lambda *X: act_new_task())
add_key_binding(main_win, '<Control><Shift>l', lambda *X: do_layout(LAYOUT[(LAYOUT.index(Props['layout/layout-set'])+1)%len(LAYOUT)]))
add_key_binding(main_win, '<Control><Shift>w', taskbody_view_toggle_wrap)
main_win.connect('delete-event', lambda *X: main_quit())


box_main = gtk.HBox()
main_win.add(box_main)
box_savedsearches = ScrolledWidget(savedsearches_view)
box_tasklist = gtk.VBox()
box_tasklist.pack_start(searchbox, expand=False)
box_tasklist.pack_start(ScrolledWidget(tasklist_view))
box_bottom = gtk.HBox()
box_taskview = gtk.VBox()
box_taskview.pack_start(ScrolledWidget(taskbody_view))
box_taskview.pack_start(completion_suggestions_box, expand=False)
box_auxtools = gtk.VBox()
box_auxtools.pack_start(calendar)

LAYOUT = ['3COL', '2COL1ROW', '1COL2ROW']
def do_layout(layout):
	def unpack(w):
		p = w.get_parent()
		if p is not None:
			p.remove(w)
	
	unpack(paned1)
	unpack(paned2h)
	unpack(paned2v)
	unpack(box_savedsearches)
	unpack(box_tasklist)
	unpack(box_bottom)
	unpack(box_taskview)
	unpack(box_auxtools)
	
	if layout not in LAYOUT:
		sys.stderr.write("Unknown layout '%s', fallback to default\n" % layout)
		layout = '3COL'
	
	if layout == '3COL':
		"""
		+--+--+--+
		|  |  |  |
		|  |  |  |
		|  |  |  |
		+--+--+--+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2h)
		paned2h.pack1(box_tasklist)
		paned2h.pack2(box_taskview)
		box_taskview.pack_start(box_auxtools, expand=False)
	elif layout == '2COL1ROW':
		"""
		+--+---+
		|  |   |
		+--+---+
		|      |
		+------+
		"""
		box_main.pack_start(paned2v)
		paned2v.pack1(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	elif layout == '1COL2ROW':
		"""
		+--+---+
		|  |   |
		|  +---+
		|  |   |
		+--+---+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2v)
		paned2v.pack1(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	
	main_win.show_all()
	calendar.hide()
	completion_suggestions_box.hide()
	Props['layout/layout-set'] = layout


do_layout(Props['layout/layout-set'] or '3COL')
searchbox.grab_focus()
gtk.main()
