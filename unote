#!/usr/bin/env python
# -*- coding: utf-8 -*-

import gtk
import glib
import pango
import time
import re
import glob
import gobject
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory
from datetime import datetime
from dateutil.relativedelta import relativedelta


APPNAME = 'unote'
TODO_DIR = './test-todo.d'
TODOFILE_EXCLUDES = ['*~', '*.bak']


def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def filenameize(s):
	#s = re.sub(r'(^|/)\.\.(/|$)', '', s)
	s = re.sub(r'/', '⁄', s)
	return s

def find_nonexistent_file(directory, preferred_filename):
	filename = preferred_filename
	n = 1
	while True:
		filepath = os.path.join(directory, filename)
		if not os.path.exists(filepath): break
		n += 1
		filename = '%s (%d)' % (preferred_filename, n)
	return filepath

def str_replace_last(s, f, r):
	pos = s.rfind(f)
	if pos == -1: return s
	return s[0:pos] + r + s[pos+len(f):]


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget

class TextBuffer(gtk.TextBuffer):
	_eventhandlers = []
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.create_tag('headline', scale=pango.SCALE_LARGE)
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return self.get_slice(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True)
	def get_buffer_halves(self, textiter=None):
		if textiter is None: textiter = self.get_cursor_iter()
		return tuple(map(unicode, (self.get_slice(self.get_start_iter(), textiter, include_hidden_chars=True), self.get_slice(textiter, self.get_end_iter(), include_hidden_chars=True))))
	def get_word_halves(self, textiter, word_re=None):
		if word_re is None: word_re = r'\w'
		text_before, text_after = self.get_buffer_halves(textiter)
		first_half = re.search(word_re + r'*\Z', text_before, re.U).group(0)
		second_half = re.search(r'^'+word_re+r'*', text_after, re.U).group(0)
		return first_half, second_half
	def get_word_boundaries(self, textiter, word_re=None):
		text_before, text_after = self.get_buffer_halves(textiter)
		word_first_half, word_second_half = self.get_word_halves(textiter, word_re)
		cursor_offset = len(text_before)
		start_offset = cursor_offset - len(word_first_half)
		end_offset = cursor_offset + len(word_second_half)
		return self.get_iter_at_offset(start_offset), self.get_iter_at_offset(end_offset)
	def get_word(self, textiter, word_re=None):
		return ''.join(self.get_word_halves(textiter, word_re=word_re))
	def get_current_word(self, word_re=None):
		return self.get_word(self.get_cursor_iter(), word_re=word_re)
	def get_cursor_iter(self):
		return self.get_iter_at_mark(self.get_insert())
	def replace_current_word(self, replacement, word_re=None):
		start, end = self.get_word_boundaries(self.get_cursor_iter(), word_re)
		self.delete(start, end)
		self.insert(start, replacement)
	def connect(self, eventname, *args):
		self._eventhandlers.append(super(self.__class__, self).connect(eventname, *args))
	def disconnect(self, eventhandle):
		super(self.__class__, self).disconnect(eventhandle)
		self._eventhandlers.remove(eventhandle)
	def disable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_block(eventhandle)
	def enable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_unblock(eventhandle)
	def get_selected_text(self):
		if self.get_has_selection():
			begin, end = self.get_selection_bounds()
			return self.get_slice(begin, end, include_hidden_chars=True)
		else:
			return ''
	def replace_selected_text(self, replacement):
		if self.get_has_selection():
			self.delete_selection(False, True)
			begin_offset = self.get_property('cursor-position')
			end_offset = begin_offset + len(replacement)
			self.insert_at_cursor(replacement)
			self.select_range(self.get_iter_at_offset(begin_offset), self.get_iter_at_offset(end_offset))
	def replace_text(self, start_offset, length, replacement):
		self.delete(self.get_iter_at_offset(start_offset), self.get_iter_at_offset(start_offset+length))
		self.insert(self.get_iter_at_offset(start_offset), replacement)
	def get_current_line_boundaries(self):
		text = self.get_text_all()
		cur = self.get_property('cursor-position')
		sol = text.rfind('\n', 0, cur) + 1
		eol = text.find('\n', cur)
		if eol == -1: eol = len(text)
		return sol, eol
	def get_current_line(self):
		sol, eol = map(self.get_iter_at_offset, self.get_current_line_boundaries())
		return self.get_slice(sol, eol, include_hidden_chars=True)

class CompletionSuggestionsBox(gtk.TextView):
	_all_items = []
	_filterer_word = ''
	_shown_items = []
	_suggestion_index = -1
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.set_wrap_mode(gtk.WRAP_WORD)
		self.get_buffer().create_tag('active_suggestion', background='yellow', font='bold')
		self.get_buffer().create_tag('inactive_suggestion')
		# style
		bgcolor = gtk.gdk.Color('lightgrey')
		self.modify_base(gtk.STATE_NORMAL, bgcolor)
	def filter_for(self, word):
		last_suggestion = self.get_curret_suggestion()
		self._filterer_word = word
		self._shown_items = filter(lambda item: self._filter_func(word, item), self._all_items)
		idx = -1
		if last_suggestion is not None:
			try: idx = self._shown_items.index(last_suggestion)
			except ValueError: pass
		self.set_suggestion_index(idx)
	@staticmethod
	def _filter_func(query, option):
		if query == option: return False
		query_norm = re.sub(r'[^\w-]', '', query, flags=re.I)
		return option.find(query_norm) > -1
	def next_suggestion(self):
		idx = self._suggestion_index + 1
		if idx >= len(self._shown_items): idx = 0
		self.set_suggestion_index(idx)
		return self.get_curret_suggestion()
	def previous_suggestion(self):
		idx = self._suggestion_index - 1
		if idx < 0: idx = len(self._shown_items)-1
		self.set_suggestion_index(idx)
		return self.get_curret_suggestion()
	def get_curret_suggestion(self):
		if len(self._shown_items) == 0: return None
		return self._shown_items[self._suggestion_index]
	def set_suggestion_index(self, idx=-1):
		textbuffer = self.get_buffer()
		textbuffer.set_text('')
		for i, item in enumerate(self._shown_items):
			tagname = 'active_suggestion' if i == idx else 'inactive_suggestion'
			textbuffer.insert_with_tags_by_name(textbuffer.get_end_iter(), item, tagname)
			textbuffer.insert(textbuffer.get_end_iter(), ' ')
		self._suggestion_index = idx
	def set_items(self, items):
		self._all_items = items[:]
		self.filter_for(self._filterer_word)

class TreeStore(gtk.TreeStore):
	def __init__(self, columns):
		self.columns = {}
		types = []
		n = 0
		for col_name, col_type in columns:
			types.append(col_type)
			self.columns[col_name] = n
			n += 1
			super(self.__class__, self).__init__(*types)
	def get_column_num(self, col_name):
		return self.columns.get(col_name)
	def __getitem__(self, item):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				return super(self.__class__, self).__getitem__(item[0]).__getitem__(self.get_column_num(item[1]))
		return super(self.__class__, self).__getitem__(item)
	def __setitem__(self, item, value):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				super(self.__class__, self).__getitem__(item[0]).__setitem__(self.get_column_num(item[1]), value)
				return
		super(self.__class__, self).__setitem__(item, value)

class Calendar(gtk.Calendar):
	_marks = {}
	selected_day = (0, 0, 0)
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'mark-added': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
		'mark-removed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
	}
	date_format = '%04d-%02d-%02d'
	def __init__(self):
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		# create popup menu
		self.popup_menu = gtk.Menu()
		mi = gtk.MenuItem("Go Today")
		mi.connect('activate', self.gotoday)
		self.popup_menu.append(mi)
		self.popup_menu.show_all()
		# set initial state
		self.gotoday()
		self.connect('key-release-event', self.on_key_press_release)
		self.connect('button-press-event', self.on_mouse_click)
		self.connect('button-release-event', self.on_mouse_clicked)
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	def on_mouse_click(self, widget, event):
		if event.button == 3:
			self.popup_menu.popup(None, None, None, event.button, event.time)
			return True  # eat the event
	def on_mouse_clicked(self, widget, event):
		if event.button == 1:
			if self.get_date()[2] != 0:
				self.on_user_select_day()
				return False  # let the event pass
	def on_key_press_release(self, widget, event):
		c_year, c_month, c_day = self.get_date()
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			if c_day == self.selected_day[2]:
				self.select_day(0)
				self.selected_day = (0, 0, 0)
			else:
				self.on_user_select_day()
		elif event.keyval in [gtk.gdk.keyval_from_name('Enter'), gtk.gdk.keyval_from_name('Return')]:
			s_year, s_month, s_day = self.selected_day[:]
			space_key_event = event.copy()
			space_key_event.keyval = int(gtk.gdk.keyval_from_name('space'))
			self.emit('key-press-event', space_key_event)
			self.emit('key-release-event', space_key_event)
			m_year, m_month, m_day = self.get_date()
			if m_day == 0:
				m_year, m_month, m_day = s_year, s_month, s_day
			self.do_mark(m_year, m_month, m_day)
			self.selected_day = (s_year, s_month, s_day)
			self.on_paging()
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Up'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=-1)
			self.select_month(date.month - 1, date.year)
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Down'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=+1)
			self.select_month(date.month - 1, date.year)
	def gotoday(self, *X):
		now = time.localtime()
		self.select_month(now.tm_mon - 1, now.tm_year)
		self.select_day(now.tm_mday)
		self.selected_day = (now.tm_year, now.tm_mon, now.tm_mday)
		self.on_paging()
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in self._marks.keys():
			response.append(date_format % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		self.do_mark(c_year, c_month, c_day)
	def do_mark(self, c_year, c_month, c_day):
		was_marked = False
		for year, month, day in self._marks.keys():
			if year == c_year and month == c_month and c_day == day:
				was_marked = True
				del self._marks[(year, month, day)]
		if was_marked:
			self.emit('mark-removed', self.date_format % (c_year, c_month, c_day))
		else:
			self._marks[(c_year, c_month, c_day)] = True
			self.emit('mark-added', self.date_format % (c_year, c_month, c_day))
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)
		if c_year == self.selected_day[0] and c_month == self.selected_day[1]:
			self.select_day(self.selected_day[2])
	def on_user_select_day(self, *X):
		self.selected_day = self.get_date()

class ActionStockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None, action=None):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)
		if action is not None:
			self.connect('activate', action)

def add_treeview_columns(treeview, columns):
	for col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_title(col_title)
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		treeview.append_column(tvc)

def main_quit():
	# execute outstanding timers
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()

class PropertyTree(dict):
	savedprops = {}
	write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.iteritems():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def load_tasks():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(TODO_DIR), topdown=False, onerror=None, followlinks=True):
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in TODOFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			with open(filepath, 'r') as f:
				text = f.read()
				yield text, filepath

def get_tags(text):
	return re.findall(r'(?:^|\s|,)(#[\w-]+)', unicode(text), re.I | re.U)

def load_tasklist():
	tasklist.clear()
	for task_text, task_file in load_tasks():
		task_headline_text = task_text.split("\n", 1)[0]
		task_headline_markup = glib.markup_escape_text(task_headline_text)
		treeiter = tasklist.append(None, [task_headline_markup, task_text, task_file])
		if task_file == Props['history/last/opened-task/path']:
			tasklist_selection.select_path(tasklist.get_path(treeiter))

def on_tasklist_changed(*X):
	timer_once(0.2, process_tasklist)

def process_tasklist():
	AllTags.clear()
	def process_tasklist_taskitem(Xmodel, path, treeiter):
		task_text = tasklist[(path, 'raw_text')]
		for tag in get_tags(task_text):
			AllTags[tag] = AllTags.get(tag, 0) + 1
	tasklist.foreach(process_tasklist_taskitem)
	completion_suggestions_box.set_items(AllTags.keys())

def load_taskbody(text):
	taskbody_buffer.disable_events()
	taskbody_buffer.set_text(text)
	taskbody_buffer.enable_events()
	parse_taskbody(text)
	calendar.gotoday()

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[m[0:3].lower()]
	except KeyError: pass
	return m

def parse_taskbody(text):
	calendar_marks = []
	re_months = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
	for y, m, d in re.findall(r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + re_months + r')-(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + re_months + r')(?:-|\s+)(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	if calendar_marks or re.search(r'\bdate:', text, re.I):
		if not calendar.get_visible():
			calendar.gotoday()
		calendar.show()
	else:
		calendar.hide()

def on_tasklist_selection_change(selection):
	Xmodel, iterpaths = selection.get_selected_rows()
	for iterpath in iterpaths:
		treeiter = tasklist.get_iter(iterpath)
		task_text = tasklist[(treeiter, 'raw_text')]
		load_taskbody(task_text)
		taskbody_view.set_data('loaded-task-iter', treeiter)
		Props['history/last/opened-task/path'] = tasklist[(treeiter, 'file')]

def timer_once(sec, func, func_args=()):
	iden = func.__name__
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden]['handle'])
		del Timers[iden]
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.5, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def filter_tasklist():
	tasklist_filtered.refilter()

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	if query == '':
		return True
	task_text = model[(treeiter, 'raw_text')]
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = task_text.find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def save_task(treeiter):
	text = tasklist[(treeiter, 'raw_text')]
	task_file = tasklist[(treeiter, 'file')]
	with open(task_file, 'w') as f:
		f.write(text)

def on_taskbody_changed(*X):
	text = taskbody_buffer.get_text_all()
	# re-parse
	parse_taskbody(text)
	# represent task text in the task list
	treeiter = taskbody_view.get_data('loaded-task-iter')
	if treeiter is None:
		# don't save new task until at least one line is entered,
		# and generate file name from the first line
		m = re.search(r'^\s*(.+?)\n', text)
		if not m: return
		first_line = m.group(1)
		filepath = find_nonexistent_file(TODO_DIR, filenameize(first_line))
		treeiter = tasklist.append(None, ['', '', filepath])
	tasklist[(treeiter, 'raw_text')] = text
	# schedule save
	timer_once(5.0, save_task, (treeiter,))


# define what counts as a word in task texts:
taskbody_word_re = r'[#\w-]'

def on_taskbody_typing(textbuffer, textiter, text, length):
	first_half, second_half = textbuffer.get_word_halves(textiter, word_re=taskbody_word_re)
	if re.search(taskbody_word_re + r'$', text):
		c_word = first_half + text + second_half
	else:
		c_word = second_half
	act_taskbody_word(c_word)

def on_taskbody_erase(textbuffer, startiter, enditer):
	first_half = textbuffer.get_word_halves(startiter, word_re=taskbody_word_re)[0]
	second_half = textbuffer.get_word_halves(enditer, word_re=taskbody_word_re)[1]
	c_word = first_half+second_half
	act_taskbody_word(c_word)

def act_taskbody_word(word):
	if word.startswith('#'):
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(word)
	else:
		completion_suggestions_box.hide()

def act_change_font(*X):
	def get_current_font(textview):
		pctx = textview.get_pango_context()
		fdsc = pctx.get_font_description()
		return fdsc.to_string()
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(main_win)
	dlg.set_modal(True)
	dlg.set_font_name(Props['field/taskbody/font'] or get_current_font(taskbody_view))
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['field/taskbody/font'] = font_name
		taskbody_view.modify_font(pango.FontDescription(font_name))
	dlg.destroy()

def on_taskbody_view_menu(Xtextview, menu):
	pos = 0
	mi = ActionStockMenuItem(label=_("Default Font…"), stock_id=gtk.STOCK_SELECT_FONT, action=act_change_font)
	menu.insert(mi, pos)
	pos += 1
	mi = gtk.CheckMenuItem(label=_("Wrap"))
	mi.connect('activate', lambda mi, *X: (taskbody_view.set_wrap_mode(gtk.WRAP_NONE), mi.set_active(False)) if taskbody_view.get_wrap_mode() != gtk.WRAP_NONE else (taskbody_view.set_wrap_mode(gtk.WRAP_WORD), mi.set_active(True)))
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	menu.show_all()

def on_taskbody_view_keypress(widget, event):
	tab = False
	shift_tab = False
	if not event.state & gtk.gdk.CONTROL_MASK:
		tab = event.keyval == gtk.gdk.keyval_from_name('Tab') and not event.state & gtk.gdk.SHIFT_MASK
		shift_tab = (event.keyval == gtk.gdk.keyval_from_name('Tab') and event.state & gtk.gdk.SHIFT_MASK) or event.keyval == gtk.gdk.keyval_from_name('ISO_Left_Tab')
	if completion_suggestions_box.get_visible():
		if tab:
			completion_suggestions_box.next_suggestion()
			return True  # prevent event propagation
		elif shift_tab:
			completion_suggestions_box.previous_suggestion()
			return True
		elif event.keyval in [gtk.gdk.keyval_from_name('Return'), gtk.gdk.keyval_from_name('Enter')]:
			suggestion = completion_suggestions_box.get_curret_suggestion()
			if suggestion is not None:
				taskbody_buffer.replace_current_word(suggestion+' ', word_re=taskbody_word_re)
				completion_suggestions_box.hide()
				return True
		elif event.keyval == gtk.gdk.keyval_from_name('Escape'):
			completion_suggestions_box.hide()
			return True
	else:
		if tab or shift_tab:
			selected_text = taskbody_buffer.get_selected_text()
			if selected_text != '':
				if tab:
					selected_text = re.sub(r'^(?=.)', '\t', selected_text, flags=re.M)
				elif shift_tab:
					selected_text = re.sub(r'^\t', '', selected_text, flags=re.M)
				taskbody_buffer.replace_selected_text(selected_text)
			else:
				if tab:
					return False
				elif shift_tab:
					line = taskbody_buffer.get_current_line()
					if line.startswith('\t'):
						sol, Xeol = taskbody_buffer.get_current_line_boundaries()
						taskbody_buffer.delete(taskbody_buffer.get_iter_at_offset(sol), taskbody_buffer.get_iter_at_offset(sol+1))
			return True

def on_taskbody_view_cursor_moved(Xtextview, Xstep_size, Xcount, Xextend_selection):
	c_word = taskbody_buffer.get_current_word(word_re=taskbody_word_re)
	act_taskbody_word(c_word)

def taskbody_insert_line(s):
	pre, post = taskbody_buffer.get_buffer_halves()
	if pre[-1] != '\n': s = '\n' + s
	if post == '' or post[0] != '\n': s = s + '\n'
	taskbody_buffer.insert(taskbody_buffer.get_cursor_iter(), s)

def taskbody_remove_text_around_cursor(s):
	"""removes first occurrance of s from taskbody_buffer before the cursor
	or after the cursor, whichever is the nearest.
	removes newline if s is a complete line."""
	pre, post = taskbody_buffer.get_buffer_halves()
	pre_pos = (pre+post).rfind(s, 0, len(pre)+len(s)-2)
	post_pos = post.find(s)
	print pre_pos, post_pos
	if pre_pos > -1 and post_pos > -1:
		pre_distance = len(pre) - pre_pos - len(s)
		post_distance = post_pos
		if post_distance < pre_distance:
			remove_from_pos = len(pre)+post_pos
		else:
			remove_from_pos = pre_pos
	elif post_pos > -1:
		remove_from_pos = len(pre)+post_pos
	elif pre_pos > -1:
		remove_from_pos = pre_pos
	else:
		return False
	remove_length = len(s)
	if (remove_from_pos > 0 and (pre+post)[remove_from_pos-1] == '\n' or remove_from_pos == 0) and remove_from_pos+len(s) < len(pre+post) and (pre+post)[remove_from_pos+len(s)] == '\n':
		remove_length = remove_length + 1
	taskbody_buffer.replace_text(remove_from_pos, remove_length, '')

def act_new_task():
	tasklist_selection.unselect_all()
	taskbody_view.set_data('loaded-task-iter', None)
	taskbody_buffer.clear()
	taskbody_view.grab_focus()


Timers = {}
Props = PropertyTree()
AllTags = {}

main_win = gtk.Window()
box1 = gtk.HBox()
paned1 = gtk.HPaned()
paned2 = gtk.HPaned()
box2 = gtk.VBox()
box3 = gtk.VBox()
box4 = gtk.HBox()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))

savedsearches = TreeStore([('query', str)])
savedsearches_view = gtk.TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [(_("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)

searchbox = gtk.Entry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.connect('changed', on_searchbox_change)

tasklist = TreeStore([('headline_markup', str), ('raw_text', str), ('file', str)])
tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)
tasklist.connect('row-changed', on_tasklist_changed)
tasklist.connect('row-deleted', on_tasklist_changed)
tasklist.connect('row-inserted', on_tasklist_changed)

tasklist_view = gtk.TreeView(tasklist_filtered)
add_treeview_columns(tasklist_view, [(_("Task"), 'markup', tasklist.get_column_num('headline_markup'))])
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

taskbody_buffer = TextBuffer()
taskbody_buffer.connect('changed', on_taskbody_changed)
taskbody_buffer.connect('insert-text', on_taskbody_typing)
taskbody_buffer.connect('delete-range', on_taskbody_erase)


taskbody_view = gtk.TextView(buffer=taskbody_buffer)
taskbody_view.modify_font(pango.FontDescription(Props['field/taskbody/font'] or ''))
taskbody_view.connect('populate-popup', on_taskbody_view_menu)
taskbody_view.connect('key-press-event', on_taskbody_view_keypress)
taskbody_view.connect_after('move-cursor', on_taskbody_view_cursor_moved)


completion_suggestions_box = CompletionSuggestionsBox()


calendar = Calendar()
calendar.connect('mark-added', lambda X, date: taskbody_insert_line(date))
calendar.connect('mark-removed', lambda X, date: taskbody_remove_text_around_cursor(date))

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
add_key_binding(main_win, '<Control>f', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>n', lambda *X: act_new_task())
main_win.connect('delete-event', lambda *X: main_quit())


main_win.add(box1)
box1.pack_start(paned1)
paned1.pack1(ScrolledWidget(savedsearches_view))
paned1.pack2(paned2)
paned2.pack1(box2)
paned2.pack2(box3)
box3.pack_start(ScrolledWidget(taskbody_view))
box3.pack_start(completion_suggestions_box, expand=False)
box3.pack_start(box4, expand=False)
box4.pack_start(calendar)
box2.pack_start(searchbox, expand=False)
box2.pack_start(ScrolledWidget(tasklist_view))

main_win.show_all()
calendar.hide()
completion_suggestions_box.hide()
searchbox.grab_focus()
gtk.main()
