#!/usr/bin/env python
# -*- coding: utf-8 -*-

try:
	import gtk
except ImportError:
	import gi
	from gi import pygtkcompat
	pygtkcompat.enable() 
	pygtkcompat.enable_gtk(version='2.0')
	import gtk
import glib
import pango
import gobject
import time
import re
import glob
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory
from datetime import datetime
from dateutil.relativedelta import relativedelta
import xattr
import errno
import traceback
import inotifyx
import Queue
import threading
gtk.gdk.threads_init()
import urllib2
import unicodedata


APPNAME = 'unote'
do_create_notes_dir = False
try:
	NOTES_DIR = sys.argv[1]
except IndexError:
	NOTES_DIR = os.path.expanduser('~/Notes')
	do_create_notes_dir = True
NOTESFILE_EXCLUDES = ['*~', '*.bak']

RE_MONTHNAMES = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
RE_DAYSOFMONTH = r'0?[1-9]|[12][0-9]|3[01]'
RE_DATE = r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + RE_MONTHNAMES + r')-(' + RE_DAYSOFMONTH + r')\b'
# define what counts as a word in task texts and search query text:
taskbody_word_re = r'[#\w-]'


NOTES_DIR = NOTES_DIR.rstrip(os.path.sep)
NOTES_ARCHIVE_DIR = os.path.join(NOTES_DIR, '.Archive')
NOTES_ARCHIVE_DIR = NOTES_ARCHIVE_DIR.rstrip(os.path.sep)


def getsizeofrecursive(x):
	size = 0
	if hasattr(x, '__iter__'):
		for y in x: size += getsizeofrecursive(y)
	else:
		size += sys.getsizeof(x)
	return size

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def filenameize(s):
	#s = re.sub(r'(^|/)\.\.(/|$)', '', s)
	s = re.sub(os.path.sep, '⁄', s)
	return s

def find_nonexistent_file(directory, preferred_filename):
	filename = preferred_filename
	n = 1
	while True:
		filepath = os.path.join(directory, filename)
		if not os.path.exists(filepath): break
		n += 1
		filename = '%s (%d)' % (preferred_filename, n)
	return filepath

def str_replace_last(s, f, r):
	pos = s.rfind(f)
	if pos == -1: return s
	return s[0:pos] + r + s[pos+len(f):]

def nulsplit(x):
	if x is None:
		return []
	else:
		return x.split(chr(0))

def run_async(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			os.execvp(cmd, args)
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)' % (e.strerror, e.errno)
		if e.filename is not None:
			text += '\n%s' % (e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None, stock_no=None, parent=None):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_no is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_NO).hide()
		btn_no = gtk.Button(label=stock_no[0], stock=stock_no[1])
		dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
		btn_no.show()
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = gtk.Button(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget

class MarkupText(str):
	def __init__(self, s):
		pass

class StatusLabel(gtk.HBox):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.states = []
	def add_state(self, label):
		if label not in self.states:
			self.states.append(label)
			self.refresh()
	def remove_state(self, label):
		if label in self.states:
			self.states.remove(label)
			self.refresh()
	def refresh(self):
		for widget in self.get_children():
			self.remove(widget)
			del widget
		for n, label in enumerate(self.states):
			if n > 0:
				self.pack_start(gtk.VSeparator(), expand=False, fill=False, padding=2)
			lbl = gtk.Label(label)
			if isinstance(label, MarkupText): lbl.set_use_markup(True)
			self.pack_start(lbl, expand=False, fill=False, padding=2)
		self.show_all()


class Patch(object):
	"""
	License: Public domain (CC0)
	Author: Isaac Turner 2016/12/05
	Source: https://gist.github.com/noporpoise/16e731849eb1231e86d78f9dfeca3abc
	"""
	import difflib
	_no_eol = '\ No newline at end of file'
	_hdr_pat = re.compile('^@@ -(\d+),?(\d+)? \+(\d+),?(\d+)? @@$')

	@classmethod
	def make_patch(selfclass, a, b):
	  """
	  Get unified string diff between two strings. Trims top two lines.
	  Returns empty string if strings are identical.
	  """
	  diffs = selfclass.difflib.unified_diff(a.splitlines(True),b.splitlines(True),n=0)
	  try: X, X = next(diffs),next(diffs)
	  except StopIteration: pass
	  return ''.join([d if d[-1] == '\n' else d+'\n'+selfclass._no_eol+'\n' for d in diffs])
	
	@classmethod
	def apply_patch(selfclass, s, patch, revert=False):
	  """
	  Apply patch to string s to recover newer string.
	  If revert is True, treat s as the newer string, recover older string.
	  """
	  s = s.splitlines(True)
	  p = patch.splitlines(True)
	  t = ''
	  i = sl = 0
	  (midx,sign) = (1,'+') if not revert else (3,'-')
	  while i < len(p) and p[i].startswith(("---","+++")): i += 1 # skip header lines
	  while i < len(p):
	    m = selfclass._hdr_pat.match(p[i])
	    if not m:
	      raise Exception("Bad patch -- regex mismatch [line "+str(i)+"]")
	    l = int(m.group(midx))-1 + (m.group(midx+1) == '0')
	    if sl > l or l > len(s):
	      raise Exception("Bad patch -- bad line num [line "+str(i)+"]")
	    t += ''.join(s[sl:l])
	    sl = l
	    i += 1
	    while i < len(p) and p[i][0] != '@':
	      if i+1 < len(p) and p[i+1][0] == '\\': line = p[i][:-1]; i += 2
	      else: line = p[i]; i += 1
	      if len(line) > 0:
	        if line[0] == sign or line[0] == ' ': t += line[1:]
	        sl += (line[0] != sign)
	  t += ''.join(s[sl:])
	  return t

def get_word_halves(text, pos, word_re=None):
	if word_re is None: word_re = r'\w'
	text_before, text_after = text[0:pos], text[pos:]
	first_half = re.search(word_re + r'*\Z', text_before, re.U).group(0)
	second_half = re.search(r'^'+word_re+r'*', text_after, re.U).group(0)
	return first_half, second_half

def current_word(text, pos, word_re=None):
	return ''.join(get_word_halves(text, pos, word_re))

class TextEntry(gtk.Entry):
	def get_text(self):
		return unicode(super(self.__class__, self).get_text())
	@property
	def text(self):
		return self.get_text()
	@text.setter
	def text(self, newtext):
		self.set_text(newtext)

class TextBuffer(gtk.TextBuffer):
	# at least this many char addition+removal triggers an undo checkpoint:
	undo_checkpoint_threshold = 32
	undo_stack_size_limit = 2*1024*1024
	
	def __init__(self, *args):
		self._eventhandlers = []
		super(self.__class__, self).__init__(*args)
		self.create_tag('headline', scale=pango.SCALE_X_LARGE)
		self.create_tag('strike', strikethrough=True)
		self.create_tag('bold', weight=pango.WEIGHT_ULTRABOLD)
		self.create_tag('code', family='Monospace')
		self.create_tag('link', foreground='blue', underline=pango.UNDERLINE_SINGLE)
		self.create_tag('hidden', invisible=True)
		self.create_tag('alert', foreground='red')
		self._undo_recording = True
		self._undo_last_cursor_pos = None
		super(self.__class__, self).connect('delete-range', self._on_delete)
		super(self.__class__, self).connect('insert-text', self._on_insert)
		self.reinit('')
	def reinit(self, text=''):
		self.set_text(text)
		self.undo_stack = []
		self.undo_stack_index = -1
		self.undo_reference_content = text
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return unicode(self.get_slice(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True))
	def get_buffer_halves(self, textiter=None):
		if textiter is None: textiter = self.cursor_iter
		return tuple(map(unicode, (self.get_slice(self.get_start_iter(), textiter, include_hidden_chars=True), self.get_slice(textiter, self.get_end_iter(), include_hidden_chars=True))))
	def get_word_halves(self, textiter, word_re):
		first_half, second_half = self.get_buffer_halves(textiter)
		return get_word_halves(first_half+second_half, len(first_half), word_re)
	def get_word_boundaries(self, textiter, word_re=None):
		text_before, text_after = self.get_buffer_halves(textiter)
		word_first_half, word_second_half = self.get_word_halves(textiter, word_re)
		cursor_offset = len(text_before)
		start_offset = cursor_offset - len(word_first_half)
		end_offset = cursor_offset + len(word_second_half)
		return self.get_iter_at_offset(start_offset), self.get_iter_at_offset(end_offset)
	def get_word(self, textiter, word_re=None):
		return ''.join(self.get_word_halves(textiter, word_re=word_re))
	def get_current_word(self, word_re=None):
		return self.get_word(self.cursor_iter, word_re=word_re)
	@property
	def cursor_iter(self):
		return self.get_iter_at_mark(self.get_insert())
	@property
	def cursor_pos(self):
		#return len(self.get_buffer_halves()[0])
		return self.get_property('cursor-position')
	@cursor_pos.setter
	def cursor_pos(self, pos):
		self.place_cursor(self.get_iter_at_offset(pos))
	def replace_current_word(self, replacement, word_re=None):
		start, end = self.get_word_boundaries(self.cursor_iter, word_re)
		self.delete(start, end)
		self.insert(start, replacement)
	def connect(self, eventname, *args):
		self._eventhandlers.append(super(self.__class__, self).connect(eventname, *args))
	def disconnect(self, eventhandle):
		super(self.__class__, self).disconnect(eventhandle)
		self._eventhandlers.remove(eventhandle)
	def disable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_block(eventhandle)
	def enable_events(self):
		for eventhandle in self._eventhandlers:
			self.handler_unblock(eventhandle)
	def get_selected_text(self):
		if self.get_has_selection():
			begin, end = self.get_selection_bounds()
			return self.get_slice(begin, end, include_hidden_chars=True)
		else:
			return ''
	def replace_selected_text(self, replacement):
		if self.get_has_selection():
			self.delete_selection(False, True)
			begin_offset = self.cursor_pos
			end_offset = begin_offset + len(replacement)
			self.insert_at_cursor(replacement)
			self.select_range(self.get_iter_at_offset(begin_offset), self.get_iter_at_offset(end_offset))
	def replace_text(self, start_offset, length, replacement):
		self.delete(self.get_iter_at_offset(start_offset), self.get_iter_at_offset(start_offset+length))
		self.insert(self.get_iter_at_offset(start_offset), replacement)
	def get_current_line_boundaries(self):
		text = self.get_text_all()
		cur = self.cursor_pos
		sol = text.rfind('\n', 0, cur) + 1
		eol = text.find('\n', cur)
		if eol == -1: eol = len(text)
		return sol, eol
	def get_current_line(self):
		sol, eol = map(self.get_iter_at_offset, self.get_current_line_boundaries())
		return self.get_slice(sol, eol, include_hidden_chars=True)
	def apply_tag_by_name(self, tagname, pos1, pos2):
		super(self.__class__, self).apply_tag_by_name(tagname, self.get_iter_at_offset(pos1), self.get_iter_at_offset(pos2))
	def remove_all_tags(self, start=None, end=None):
		if start is None: start = self.get_start_iter()
		if end is None: end = self.get_end_iter()
		super(self.__class__, self).remove_all_tags(start, end)
	def get_tag_by_name(self, tagname):
		return self.get_tag_table().lookup(tagname)
	@staticmethod
	def _undo_helper_chardistance(a, b):
		import difflib
		distance = 0
		for change in difflib.ndiff(a, b):
			if change[0] in ['+', '-']:
				distance += 1
		return distance
	def _undo_track_position(self):
		# don't forget to call _undo_track_position exactly once per editing event (while recording undo)
		"save the current cursor position to the last cursor position and return the previous last position"
		cur_pos = self.cursor_pos
		last_pos = self._undo_last_cursor_pos
		self._undo_last_cursor_pos = self.cursor_pos
		return last_pos
	def _on_delete(self, *X):
		# pass through to check whether a checkpoint is needed or not
		self._undo_checkpoint()
	def _on_insert(self, textbuffer, textiter, inserted_text, Xlength):
		if self._undo_recording:
			length = len(inserted_text.decode('utf-8'))
			if length > 1:
				# a text block is inserted
				self._undo_track_position()
				self.create_undo_checkpoint()
				return
			prev_char = None if self.cursor_pos == 0 else self.get_text_all()[self.cursor_pos - 1]
			if prev_char is not None:
				if (inserted_text == '\n') != (prev_char == '\n'):
					# a non-consecutive Enter is hit
					self._undo_track_position()
					self.create_undo_checkpoint()
					return
			# pass through to check whether a checkpoint is needed or not
			self._undo_checkpoint()
	def _undo_checkpoint(self, *X):
		if self._undo_recording:
			last_pos = self._undo_track_position()
			if last_pos is not None and abs(self.cursor_pos - last_pos) > 1:
				# if the cursor position is more than 1 char away, then the text
				# is edited elsewhere than the previous edit action
				self.create_undo_checkpoint()
				return
			text = self.get_text_all()
			if self._undo_helper_chardistance(self.undo_reference_content, text) > self.undo_checkpoint_threshold:
				# if user typed a much then make a checkpoint
				self.create_undo_checkpoint()
	def create_undo_checkpoint(self):
		# TODO: merge adjacent too small patches together
		text = self.get_text_all()
		patch = Patch.make_patch(self.undo_reference_content, text)
		if patch != '':
			del self.undo_stack[self.undo_stack_index+1:]
			self.undo_stack.append((patch, self.cursor_pos))
			self.undo_stack_index += 1
			self.undo_reference_content = text
			while getsizeofrecursive(self.undo_stack) > self.undo_stack_size_limit:
				del self.undo_stack[0]
				self.undo_stack_index -= 1
	def undo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index >= 0:
			patch, pos = self.undo_stack[self.undo_stack_index]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=True)
			self._undo_recording = False
			self.set_text(replacement)
			self.cursor_pos = pos
			self._undo_recording = True
			self.undo_stack_index -= 1
			self.undo_reference_content = replacement
	def redo(self):
		self.create_undo_checkpoint()
		if self.undo_stack_index < len(self.undo_stack) - 1:
			patch, pos = self.undo_stack[self.undo_stack_index + 1]
			replacement = Patch.apply_patch(self.get_text_all(), patch, revert=False)
			self._undo_recording = False
			self.set_text(replacement)
			self.cursor_pos = pos
			self._undo_recording = True
			self.undo_stack_index += 1
			self.undo_reference_content = replacement

def textview_get_iter_from_window_widget_coordinates(textview, x, y):
	x, y = textview.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, int(x), int(y))
	return textview.get_iter_at_location(x, y)

class CompletionSuggestionsBox(gtk.TextView):
	def __init__(self, *args):
		self._all_items = []
		self._filterer_word = ''
		self._shown_items = []
		self._suggestion_index = -1
		super(self.__class__, self).__init__(*args)
		self.set_wrap_mode(gtk.WRAP_WORD)
		self.set_editable(False)
		self.get_buffer().create_tag('active_suggestion', background='yellow', weight=pango.WEIGHT_BOLD)
		self.get_buffer().create_tag('inactive_suggestion')
		# style
		bgcolor = gtk.gdk.Color('lightgrey')
		self.modify_base(gtk.STATE_NORMAL, bgcolor)
	def filter_for(self, word):
		last_suggestion = self.current_suggestion
		self._filterer_word = word
		self._shown_items = filter(lambda item: self._filter_func(word, item), self._all_items)
		idx = -1
		if last_suggestion is not None:
			try: idx = self._shown_items.index(last_suggestion)
			except ValueError: pass
		self.set_suggestion_index(idx)
	@staticmethod
	def _filter_func(query, item):
		if query == item['word']: return False
		query_norm = re.sub(r'[^\w-]', '', query, flags=re.I|re.U)
		return item['word'].find(query_norm) > -1
	def next_suggestion(self):
		idx = self._suggestion_index + 1
		if idx >= len(self._shown_items): idx = 0
		self.set_suggestion_index(idx)
		return self.current_suggestion_word
	def previous_suggestion(self):
		idx = self._suggestion_index - 1
		if idx < 0: idx = len(self._shown_items)-1
		self.set_suggestion_index(idx)
		return self.current_suggestion_word
	@property
	def current_suggestion(self):
		if len(self._shown_items) == 0: return None
		return self._shown_items[self._suggestion_index]
	@property
	def current_suggestion_word(self):
		return (self.current_suggestion or {'word': None})['word']
	def set_suggestion_index(self, idx=-1):
		textbuffer = self.get_buffer()
		textbuffer.set_text('')
		for i, item in enumerate(self._shown_items):
			tagname = 'active_suggestion' if i == idx else 'inactive_suggestion'
			textbuffer.insert_with_tags_by_name(textbuffer.get_end_iter(), item['label'], tagname)
			textbuffer.insert(textbuffer.get_end_iter(), ' ')
		self._suggestion_index = idx
	def set_items(self, items):
		for item in items:
			assert isinstance(item, dict)
			assert item.has_key('word')
		self._all_items = items[:]
		for item in self._all_items:
			if not item.has_key('label') or item['label'] is None:
				item['label'] = item['word']
		self.filter_for(self._filterer_word)

class TreeModelRow(object):
	"""proxy class for inextensible gtk.TreeModelRow"""
	def __init__(self, treemodelrow, upstream_treemodel):
		self.real_treemodelrow = treemodelrow
		self.upstream_treemodel = upstream_treemodel
	@property
	def path(self):
		return self.real_treemodelrow.path
	@property
	def iter(self):
		return self.real_treemodelrow.iter
	@property
	def model(self):
		return self.real_treemodelrow.model
	def __getitem__(self, item):
		item = self.upstream_treemodel.get_column_num(item)
		answer = gtk.TreeModel.get(self.model, self.iter, item)[0]
		return self.upstream_treemodel.convert_cell(item, answer)
	def __setitem__(self, item, value):
		item = self.upstream_treemodel.get_column_num(item)
		self.real_treemodelrow[item] = value
	def __len__(self):
		return self.real_treemodelrow.__len__()

class TreeModelProxy(object):
	@staticmethod
	def _proxy_foreach(model, treepath, treeiter, _proxy_userdata):
		func = _proxy_userdata['func']
		userdata = _proxy_userdata['userdata']
		derived_model = _proxy_userdata['derived_model']
		return func(derived_model, treepath, treeiter, userdata)

class TreeModelFilter(gtk.TreeModelFilter):
	_proxy_implemented = ['__getitem__', 'foreach', 'get', 'get_value']
	def __init__(self, upstream_treemodel, treemodel_filter):
		self._proxy_real_treemodel = treemodel_filter
		self._proxy_upstream_treemodel = upstream_treemodel
	def __getitem__(self, item):
		answer = self._proxy_real_treemodel.__getitem__(item)
		return TreeModelRow(answer, self._proxy_upstream_treemodel)
	def foreach(self, func, userdata):
		_proxy_userdata = {'func': func, 'userdata': userdata, 'derived_model': self}
		self._proxy_real_treemodel.foreach(TreeModelProxy._proxy_foreach, _proxy_userdata)
	def get(self, row, *columns):
		raise(Exception('unimplemented'))
	def get_value(self, treeiter, column):
		raise(Exception('unimplemented'))
	def __len__(self):
		return len(self._proxy_real_treemodel)
	def __getattribute__(self, attr):
		if attr.startswith('_proxy_') or attr in self._proxy_implemented:
			return object.__getattribute__(self, attr)
		else:
			return object.__getattribute__(self._proxy_real_treemodel, attr)

class TreeModelSort(gtk.TreeModelSort):
	def __init__(self, basemodel):
		if hasattr(basemodel, '_proxy_upstream_treemodel'):
			self._proxy_upstream_treemodel = basemodel._proxy_upstream_treemodel
		else:
			self._proxy_upstream_treemodel = basemodel
		if hasattr(basemodel, '_proxy_real_treemodel'):
			basemodel = basemodel._proxy_real_treemodel
		super(self.__class__, self).__init__(basemodel)
	def __getitem__(self, item):
		answer = super(self.__class__, self).__getitem__(item)
		return TreeModelRow(answer, self._proxy_upstream_treemodel)
	def foreach(self, func, userdata):
		_proxy_userdata = {'func': func, 'userdata': userdata, 'derived_model': self}
		super(self.__class__, self).foreach(TreeModelProxy._proxy_foreach, _proxy_userdata)
	def get(self, row, *columns):
		raise(Exception('unimplemented'))
	def get_value(self, treeiter, column):
		raise(Exception('unimplemented'))

class TreeStore(gtk.TreeStore):
	__gsignals__ = {
		'changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'set-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
	}
	def __init__(self, *columns):
		self.column = {}
		self.reader = {}
		self.empty = []
		types = []
		n = 0
		for col_name, col_type in columns:
			empty_value = None
			if col_type == unicode:
				col_type = str
				self.reader[n] = self.to_unicode
			if col_type == str:
				empty_value = ''
			elif col_type in [int, float]:
				empty_value = 0
			self.empty.append(empty_value)
			types.append(col_type)
			self.column[col_name] = n
			n += 1
		super(self.__class__, self).__init__(*types)
		for event in 'row-changed', 'row-deleted', 'row-inserted':
			self.connect_after(event, self.emit_signal, 'changed')
			self.connect_after(event, self.emit_signal, 'set-changed')
		self.connect_after('rows-reordered', self.emit_signal, 'changed')
	def emit_signal(self, *args):
		signal_name = args[-1]
		self.emit(signal_name)
	@staticmethod
	def to_unicode(s):
		if s is None: return None
		return unicode(s)
	def get_column_num(self, col_name):
		if isinstance(col_name, int): return col_name
		return self.column[col_name]
	def get(self, row, *columns):
		if type(row) == tuple:
			row = self.get_iter(row)  # tree iterator path was given
		if len(columns) == 0:
			return tuple()
		columns = list(columns)
		for i, col in enumerate(columns):
			columns[i] = self.get_column_num(col)
		answer = super(self.__class__, self).get(row, *columns)
		answer = list(answer)
		for i, col_num in enumerate(columns):
			answer[i] = self.convert_cell(col_num, answer[i])
		answer = tuple(answer)
		return answer
	def get_value(self, treeiter, column):
		raise(Exception('unimplemented'))
	def convert_cell(self, col_num, cell_value):
		if self.reader.has_key(col_num):
			return self.reader[col_num](cell_value)
		return cell_value
	def __getitem__(self, item):
		answer = super(self.__class__, self).__getitem__(item)
		return TreeModelRow(answer, self)
	def _row_dict_to_list(self, row):
		if type(row) == dict:
			cols = row
			row = self.empty[:]
			for col_name, value in cols.iteritems():
				row[self.get_column_num(col_name)] = value
		return row
	def append(self, parent, row):
		return super(self.__class__, self).append(parent, self._row_dict_to_list(row))
	def insert_after(self, parent, sibling, row):
		return super(self.__class__, self).insert_after(parent, sibling, self._row_dict_to_list(row))
	def insert_before(self, parent, sibling, row):
		return super(self.__class__, self).insert_before(parent, sibling, self._row_dict_to_list(row))
	def set(self, treeiter, *itempairs):
		if len(itempairs) == 0: return
		if type(itempairs[0]) == dict:
			cols = itempairs[0]
			itempairs = []
			for col_name, value in cols.iteritems():
				itempairs.extend([self.get_column_num(col_name), value])
		super(self.__class__, self).set(treeiter, *itempairs)
	def get_cells_by_column(self, col_name):
		treeiter = self.get_iter_root()
		while treeiter is not None:
			yield self[treeiter][col_name]
			treeiter = successor_iter(self, treeiter)
	def walk_columns(self, *columns):
		"""yields a sequence of [TreeModelRow, depth, value-1, value-2, ..., value-n] lists
		for depth being the row's level on the tree and value-1 to value-n being the 
		content of cells in the requested columns in each row"""
		treeiter = self.get_iter_root()
		while treeiter is not None:
			row = self[treeiter]
			answer = [row]
			answer.extend(self.get(treeiter, *columns))
			yield answer
			treeiter = successor_iter(self, row.iter)
	def filter_new(self, root=None):
		treemodelfilter = super(self.__class__, self).filter_new(root=root)
		return TreeModelFilter(self, treemodelfilter)

class TreeView(gtk.TreeView):
	__gsignals__ = {
		'menu-popup': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT)),
		'header-menu-popup': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT)),
	}
	def __init__(self, model):
		super(self.__class__, self).__init__(model)
		self.connect('button-press-event', self._on_button_click)
		self.connect('realize', self._on_realize)
		self.connect('columns-changed', self._on_columns_changed)
		self.connect('key-release-event', self._on_key_release)
	def _on_key_release(self, widget, event):
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			iterpath, tv_col = self.get_cursor()
			cr = tv_col.get_cell_renderers()[0]
			cr.on_start_editing(event, widget, ','.join(map(str, iterpath)), self.get_background_area(iterpath, tv_col), self.get_cell_area(iterpath, tv_col), 0)
	def _on_button_click(self, widget, event):
		if event.button == 3:
			x, y = int(event.x), int(event.y)
			t = self.get_path_at_pos(x, y)
			if t is not None:
				treepath, tv_col, cell_x, cell_y = t
			else:
				treepath, tv_col, cell_x, cell_y = None, None, None, None
			popup_menu = gtk.Menu()
			if not self.emit('menu-popup', popup_menu, treepath, tv_col, cell_x, cell_y):
				# event is not handled by any handlers, so do it ourself
				if popup_menu.get_children():
					popup_menu.show_all()
					popup_menu.popup(None, None, None, event.button, event.time)
			return True
	def _on_realize(self, widget):
		for tvc in self.get_columns():
			self._column_setup_events(tvc)
	def _on_columns_changed(self, widget):
		# clear 'layoutstash', it is needed for CellRendererTextOverflow
		self.set_data('layoutstash', {})
	def append_column(self, tvc):
		super(self.__class__, self).append_column(tvc)
		self._column_setup_events(tvc)
	def _column_setup_events(self, tvc):
		if hasattr(tvc, 'setup_events'):
			tvc.setup_events()
			if not tvc.get_data('treeview-connect-done'):
				tvc.connect('button-press-event', self._on_column_click)
				tvc.set_data('treeview-connect-done', True)
	def _on_column_click(self, col_widget, event):
		if event.button == 3:
			popup_menu = gtk.Menu()
			if not self.emit('header-menu-popup', popup_menu, col_widget):
				popup_menu.show_all()
				popup_menu.popup(None, None, None, event.button, event.time)
			return True
	@staticmethod
	class ColumnNotFoundException(Exception):
		pass
	def get_column_by_name(self, colname):
		for col in self.get_columns():
			if col.get_name() == colname:
				return col
		raise TreeView.ColumnNotFoundException(colname)

class TreeViewColumn(gtk.TreeViewColumn):
	__gsignals__ = {
		'button-press-event': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT,)),
	}
	def set_title(self, title):
		tvc_label = gtk.Label(title)
		tvc_label.show()
		self.set_widget(tvc_label)
	
	def setup_events(self, *X):
		# this method should be called when the TreeView is realized.
		if not self.get_data('setup-events-done'):
			# find the button representing the treeview column header
			# and propagate up events.
			w = self.get_widget()
			while not isinstance(w, gtk.Button):
				w = w.get_parent()
			if w is not None:
				w.connect('button-press-event', lambda widget, event: self.emit('button-press-event', event))
			self.set_data('setup-events-done', True)

class Calendar(gtk.Calendar):
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'mark-added': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
		'mark-removed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
	}
	date_format = '%04d-%02d-%02d'
	def __init__(self):
		self._marks = {}
		self.selected_day = (0, 0, 0)
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		# create popup menu
		self.popup_menu = gtk.Menu()
		mi = gtk.ImageMenuItem(stock_id=gtk.STOCK_JUMP_TO)
		mi.set_label("Go Today")
		mi.connect('activate', self.goto_today)
		self.popup_menu.append(mi)
		self.popup_menu.show_all()
		# set initial state
		self.goto_today()
		self.connect('key-release-event', self.on_key_press_release)
		self.connect('button-press-event', self.on_mouse_click)
		self.connect('button-release-event', self.on_mouse_clicked)
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	def on_mouse_click(self, widget, event):
		if event.button == 3:
			self.popup_menu.popup(None, None, None, event.button, event.time)
			return True  # eat the event
	def on_mouse_clicked(self, widget, event):
		if event.button == 1:
			if self.get_date()[2] != 0:
				self.on_user_select_day()
				return False  # let the event pass
	def on_key_press_release(self, widget, event):
		c_year, c_month, c_day = self.get_date()
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			if c_day == self.selected_day[2]:
				self.select_day(0)
				self.selected_day = (0, 0, 0)
			else:
				self.on_user_select_day()
		elif event.keyval in [gtk.gdk.keyval_from_name('Enter'), gtk.gdk.keyval_from_name('Return')]:
			s_year, s_month, s_day = self.selected_day[:]
			space_key_event = event.copy()
			space_key_event.keyval = int(gtk.gdk.keyval_from_name('space'))
			self.emit('key-press-event', space_key_event)
			self.emit('key-release-event', space_key_event)
			m_year, m_month, m_day = self.get_date()
			if m_day == 0:
				m_year, m_month, m_day = s_year, s_month, s_day
			self.do_mark(m_year, m_month, m_day)
			self.selected_day = (s_year, s_month, s_day)
			self.on_paging()
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Up'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=-1)
			self.select_month(date.month - 1, date.year)
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Down'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=+1)
			self.select_month(date.month - 1, date.year)
	def goto(self, y, m, d=0):
		self.select_month(m - 1, y)
		if d > 0:
			self.select_day(d)
			self.selected_day = (y, m, d)
		self.on_paging()
	def goto_today(self, *X):
		now = time.localtime()
		self.goto(now.tm_year, now.tm_mon, now.tm_mday)
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in self._marks.keys():
			response.append(date_format % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		self.do_mark(c_year, c_month, c_day)
	def do_mark(self, c_year, c_month, c_day):
		was_marked = False
		for year, month, day in self._marks.keys():
			if year == c_year and month == c_month and c_day == day:
				was_marked = True
				del self._marks[(year, month, day)]
		if was_marked:
			self.emit('mark-removed', self.date_format % (c_year, c_month, c_day))
		else:
			self._marks[(c_year, c_month, c_day)] = True
			self.emit('mark-added', self.date_format % (c_year, c_month, c_day))
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)
		if c_year == self.selected_day[0] and c_month == self.selected_day[1]:
			self.select_day(self.selected_day[2])
	def on_user_select_day(self, *X):
		self.selected_day = self.get_date()

class ActionStockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None, action=None, action_userdata=tuple(), use_underline=False):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)
			self.set_use_underline(use_underline)
		if action is not None:
			self.connect('activate', action, *action_userdata)

class CheckMenuItem(gtk.CheckMenuItem):
	def __init__(self, label=None, markup=None, use_underline=False):
		super(self.__class__, self).__init__(label=label, use_underline=use_underline)
		if markup is not None:
			def find_label(w):
				if isinstance(w, gtk.Label):
					return w
				if hasattr(w, 'get_children'):
					for w in w.get_children():
						w = find_label(w)
						if w is not None:
							return w
			self.set_label('.')
			l = find_label(self)
			l.set_markup(markup)

def save_treeview_column_sort(tvc):
	Props['field/tasklist/sort-by'] = tvc.get_name()
	Props['field/tasklist/sort-order'] = int(tvc.get_sort_order())

def save_treeview_column_width(tvc, Xprop):
	Props['layout/column/%s/width' % tvc.get_name()] = tvc.get_width()

class CellRendererTextOverflow(gtk.GenericCellRenderer):
	"""
	This class implements a CellRenderer which renders (markup) text just like
	CellRendererText, but allows the text content to flow over to adjacent empty cells.
	"""
	__gproperties__ = {
		'text': (gobject.TYPE_STRING, 'Text', 'Text', None, gobject.PARAM_READWRITE),
		'markup': (gobject.TYPE_STRING, 'Markup', 'Markup', None, gobject.PARAM_READWRITE),
		'editable': (gobject.TYPE_BOOLEAN, 'Editable', 'Editable', False, gobject.PARAM_READWRITE),
	}
	def __init__(self):
		super(self.__class__, self).__init__()
		self.__gobject_init__()
		self.cr_txt = gtk.CellRendererText()
		self.the_props = {'markup': None}
	def connect(self, *args):
		self.cr_txt.connect(*args)
	def do_set_property(self, pspec, val):
		if pspec.name == 'markup':
			self.the_props[pspec.name] = val
		self.cr_txt.set_property(pspec.name, val)
	def do_get_property(self, pspec):
		if pspec.name == 'markup':
			# CellRendererText can not read 'markup' property back, so we do
			return self.the_props[pspec.name]
		return self.cr_txt.get_property(pspec.name)
	def set_property(self, prop, val):
		return self.cr_txt.set_property(prop, val)
	def on_get_size(self, widget, cell_area):
		x, y, w, h = self.cr_txt.get_size(widget, cell_area)
		return x, y, w, h
	def get_next_column(self, current_column=None):
		"""Return the column at the right side of 'current_column'
		or, if 'current_column' is None, of the column which this CellRenderer is in."""
		tvc = self.get_data('treeviewcolumn')
		tv = tvc.get_tree_view()
		columns = tv.get_columns()
		if current_column is None:
			current_column = tvc
		for num, col in enumerate(columns):
			if col is current_column:
				if num+1 < len(columns):
					return columns[num+1]
				return None
		return None
	def draw_layout(self, window, widget, cell_area, layout, flags):
		base_grctx = widget.style.black_gc
		if (flags & gtk.CELL_RENDERER_SELECTED) != 0: base_grctx = widget.style.white_gc
		window.draw_layout(base_grctx, cell_area.x, cell_area.y, layout)
		return False
	def on_render(self, window, widget, background_area, cell_area, expose_area, flags):
		"""Find out how much empty area we have horizontally
		by sum the width of empty cells on right of the current cell.
		Then render the (markup) text on a pango Layout.
		Save the data neccessary to draw the Layout into 'layoutstash' for each cells 
		which are found empty. Cells are identified by TreeModel path and TreeViewColumn name.
		When an actual empty cell is encountered, then recall the saved Layout (if any) and
		redraw it. It assumes that the controller routine requests us to
		render the cells from left to right in sequence and row-by-row."""
		markup = self.get_property('markup')
		text = self.get_property('text')
		
		tvc = self.get_data('treeviewcolumn')
		tvc_name = tvc.get_name()
		tv = tvc.get_tree_view()
		model = tv.get_model()
		cellinfo = tv.get_path_at_pos(cell_area.x, cell_area.y)
		if cellinfo is None:
			cellinfo = tv.get_path_at_pos(cell_area.x + cell_area.width, cell_area.y + cell_area.height)
		treepath = cellinfo[0]
		
		if tv.get_data('last-drawn-row-treepath') != treepath or tv.get_data('layoutstash') is None:
			tv.set_data('layoutstash', {})
		tv.set_data('last-drawn-row-treepath', treepath)
		layoutstash = tv.get_data('layoutstash')
		
		overflow_width = cell_area.width
		next_col = self.get_next_column()
		next_col_names = []
		while next_col is not None:
			next_col_content = model[treepath][next_col.get_name()]
			if next_col_content is None or next_col_content == '':
				overflow_width += next_col.get_width()
				next_col_names.append(next_col.get_name())
				next_col = self.get_next_column(next_col)
			else:
				break
		if overflow_width != cell_area.width:
			context = widget.get_pango_context()
			layout = pango.Layout(context)
			if markup:
				layout.set_markup(markup)
			elif text:
				layout.set_text(text)
			if markup or text:
				layout.set_width(overflow_width * pango.SCALE)
				layout.set_wrap(pango.WRAP_CHAR)
				layout.set_ellipsize(pango.ELLIPSIZE_END)
				xpad, ypad = self.cr_txt.get_padding()
				draw_area = cell_area.copy()
				draw_area.x += xpad
				draw_area.y += ypad
				if not layoutstash.has_key(treepath):
					layoutstash[treepath] = {}
				for colname in layoutstash[treepath].keys():
					if layoutstash[treepath][colname].has_key(tvc_name):
						del layoutstash[treepath][colname][tvc_name]
				for colname in next_col_names:
					if not layoutstash[treepath].has_key(colname):
						layoutstash[treepath][colname] = {}
					layoutstash[treepath][colname][tvc_name] = (window, widget, draw_area, layout, flags)
		else:
			# this cell's text does not flow over, so delete earlier layouts, if any
			for colname in layoutstash.get(treepath, {}).keys():
				if layoutstash[treepath][colname].has_key(tvc_name):
					del layoutstash[treepath][colname][tvc_name]
		layout_overflowcells = layoutstash.get(treepath, {}).get(tvc_name, {})
		if not markup and not text:
			# current cell is empty, but redraw those cells which flow over to this one
			for layout_args in layout_overflowcells.values():
				self.draw_layout(*layout_args)
		else:
			if layout_overflowcells:
				# current cell is not empty so delete those layouts which would be drawn on it, if any
				del layoutstash[treepath][tvc_name]
			self.cr_txt.render(window, widget, background_area, cell_area, expose_area, flags)
	def on_activate(self, event, widget, path, background_area, cell_area, flags):
		return self.cr_txt.activate(event, widget, path, background_area, cell_area, flags)
	def on_start_editing(self, event, widget, path, background_area, cell_area, flags):
		ce = self.cr_txt.start_editing(event, widget, path, background_area, cell_area, flags)
		w = gtk.Window(gtk.WINDOW_TOPLEVEL)
		w.set_keep_above(True)
		w.set_modal(True)
		w.set_skip_taskbar_hint(True)
		w.set_transient_for(main_win)
		w.set_decorated(False)
		frame = gtk.Frame(label = "Enter new value")
		frame.set_border_width(24)
		frame.set_shadow_type(gtk.SHADOW_IN)
		frame_inner = gtk.Frame()
		frame_inner.set_border_width(16)
		w.add(frame)
		frame.add(frame_inner)
		frame_inner.add(ce)
		w.show_all()
		add_key_binding(w, 'Escape', lambda *X: w.destroy())
		w.connect('destroy', lambda *X: w.destroy())
		ce.connect('remove-widget', lambda *X: w.destroy())
		ce.start_editing(event)

gobject.type_register(CellRendererTextOverflow)

def add_treeview_columns(treeview, columns):
	for col_name, col_title, col_attr, col_num in columns:
		tvc = TreeViewColumn()
		tvc.set_name(col_name)
		tvc.set_title(col_title)
		tvc.set_sort_indicator(True)
		tvc.set_sort_column_id(col_num)
		tvc.set_resizable(True)
		tvc.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
		tvc.set_reorderable(True)
		
		cr_txt = CellRendererTextOverflow()
		cr_txt.set_data('treeviewcolumn', tvc)
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		
		treeview.append_column(tvc)
		width = Props['layout/column/%s/width'%col_name]
		if width is not None:
			tvc.set_fixed_width(int(width))
		else:
			tvc.set_fixed_width(100)
		tvc.connect('notify::width', save_treeview_column_width)
		tvc.connect('clicked', save_treeview_column_sort)

def main_quit():
	act_close_task()
	# execute outstanding timers
	sys.stderr.write(_("Executing outstanding timed operations…")+'\n')
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])

	ioQueue.put(('exit', [], None))
	# quit gtk loop eventually
	glib.timeout_add(100, main_quit_exit)

def main_quit_exit():
	sys.stderr.write(_("Waiting background threads to complete…")+'\n')
	ioQueue.join()
	ioThread.join()
	sys.stderr.write(_("Background threads completed.")+'\n')
	gtk.main_quit()
	return True

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	tasklist_loader.wake()
	# load last opened task
	# FIXME: do it during it loads the tasks or when it finished
	select_or_load_task_by_file(Props['history/last/opened-task/path'])

def select_or_load_task_by_file(task_file_nonprefixed):
	def find_task_by_file(model, treepath, treeiter, data):
		c_task_file = model[treeiter]['file']
		c_task_file_nonprefixed = strip_path_prefix(c_task_file)
		if c_task_file_nonprefixed == data['file_nonprefixed']:
			data['iter'] = treeiter
			data['text'] = model[treepath]['raw_text']
			return True
	data = {'text': None, 'iter': None, 'file_nonprefixed': task_file_nonprefixed}
	model = tasklist_view.get_model()
	model.foreach(find_task_by_file, data)
	if data['iter'] is not None:
		tasklist_selection.unselect_all()
		tasklist_selection.select_iter(data['iter'])
		tasklist_view.scroll_to_cell(model.get_path(data['iter']))
	else:
		tasklist.foreach(find_task_by_file, data)
		if data['text'] is not None:
			load_task(task_file_nonprefixed, data['text'])

class PropertyTree(dict):
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.savedprops = {}
		self.write_delay = 1.2
	def _read(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
					break
		return propvalue
	def __getitem__(self, propname):
		propvalue = self._read(propname)
		if propvalue is not None:
			self.savedprops[propname] = propvalue
			super(self.__class__, self).__setitem__(propname, propvalue)
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write_all, keep_old_schedules=True)
	def _write_all(self):
		for propname, propvalue in self.iteritems():
			propvalue = str(propvalue)
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				ioQueue.put(('mkdir', [os.path.dirname(propfile)], _("saving config…")))
				ioQueue.put(('write', [propfile, propvalue], _("saving config…")))
				self.savedprops[propname] = propvalue

class HistoryList(object):
	def __init__(self, size_limit=1024000, items=[], pointer=-1):
		assert pointer < len(items)
		if len(items) > 0 and pointer == -1: pointer = len(items)-1
		assert (len(items) > 0 and pointer > 0) or (len(items) == 0 and pointer == -1)
		super(self.__class__, self).__init__()
		self.stack = items[:]
		self.pointer = pointer
		self.size_limit = size_limit
		self._on_change_func = lambda:None
	def set_size_limit(self, bytes):
		assert isinstance(bytes, int)
		self.size_limit = bytes
	def push(self, item):
		if item == '':
			# ignore empty strings
			return
		if item != self.currentitem:
			self.stack.insert(self.pointer + 1, item)
			self.pointer += 1
		while sys.getsizeof(self.stack) > self.size_limit:
			if len(self) - self.pointer < self.pointer:
				del self.stack[0]
			else:
				del self.stack[-1]
		self._on_change_func()
	def __len__(self):
		return len(self.stack)
	def __getslice__(self, s, n):
		return self.stack.__getslice__(s, n)
	@property
	def currentitem(self):
		return self.stack[self.pointer] if self.pointer > -1 else None
	def forward(self):
		goindex = self.pointer + 1
		if len(self) > goindex: self.pointer = goindex
		return self.currentitem
	def backward(self):
		goindex = self.pointer - 1
		if goindex > 0: self.pointer = goindex
		return self.currentitem
	@property
	def on_change(self):
		return self._on_change_func
	@on_change.setter
	def on_change(self, func):
		self._on_change_func = func

def strip_path_prefix(s):
	if s is None: return None
	assert s.startswith(NOTES_DIR+os.path.sep)
	return s[len(NOTES_DIR)+1:]

def add_path_prefix(s):
	if s is None: return None
	assert not s.startswith(NOTES_DIR+os.path.sep)
	return os.path.join(NOTES_DIR, s)

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def on_notes_dir_changed(fd, Xcondition):
	inotifyx.get_events(fd)
	timer_once(1.0, tasklist_loader.wake, keep_old_schedules=True)
	return True

class TasklistLoader(threading.Thread):
	def __init__(self):
		super(self.__class__, self).__init__()
		self._event_wake = threading.Event()
	def wake(self):
		self._event_wake.set()
	def run(self):
		while self._event_wake.wait():
			self._event_wake.clear()
			load_tasklist()

def load_tasks():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(NOTES_DIR), topdown=True, onerror=None, followlinks=True):
		for idx, dirname in reversed(list(enumerate(dirnames))):
			if dirname.startswith('.'):
				# don't descent into hidden directories
				del dirnames[idx]
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in NOTESFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			try:
				with open(filepath, 'r') as f:
					text = f.read()
					yield unicode(text), unicode(filepath)
			except IOError:
				traceback.print_exc()

def get_tags(text):
	return re.findall(r'(?:^|\s|,)(#[\w-]+)', text, re.I|re.U)

def update_task_in_list(treestore, treeiter, task_text=None, task_file=None, task_mtime=None, task_btime=None):
	row = {}
	if task_text is not None:
		row['raw_text'] = task_text
		row['noaccent_text'] = noaccent(task_text)
		
		# compose the task's preview text
		preview = task_text
		preview = re.sub(r'[\t ]+', ' ', preview)
		charshift = 0
		for s, e, hideranges in find_markup_positions(preview, 'bold'):
			for s, e in hideranges:
				preview = preview[0:s+charshift] + preview[e+charshift:]
				charshift -= e - s
		preview += '\n'
		head, body = preview.split('\n', 1)
		head = re.sub(r'\r', '', head)
		body = re.sub(r'[\r\n]+', ' ', body)
		body = body[0:255] + ('…' if len(body)>255 else '')
		row['headline_markup'] = '%s <span foreground="grey">%s</span>' % (glib.markup_escape_text(head), glib.markup_escape_text(body))
		
		dates = re.findall(r'\bdate:\s*(\S+)', task_text)
		if dates:
			row['date'] = dates[0]
		else:
			row['date'] = ''
		duedates = re.findall(r'\bdue:\s*(\S+)', task_text)
		if duedates:
			row['due'] = duedates[0]
		else:
			row['due'] = ''
	if task_file is not None:
		row['file'] = task_file
		if task_mtime is None:
			task_mtime = os.stat(task_file).st_mtime
		if task_btime is None:
			# with noatime mount option, atime is set on a file once when it's created,
			# so I use it as a birth date
			task_btime = os.stat(task_file).st_atime
	if task_mtime is not None:
		row['updated'] = time.strftime('%F %H:%M', time.localtime(task_mtime))
	if task_btime is not None:
		row['created'] = time.strftime('%F %H:%M', time.localtime(task_btime))
	treestore.set(treeiter, row)

def load_tasklist():
	is_gtk_locked = False
	try:
		gtk.threads_enter(); is_gtk_locked = True
		tasklist_top_label1.add_state(_("Loading notes…"))
		rows_to_forget = dict(map(lambda x: (x[1], x[0]), tasklist.walk_columns('file')))
		gtk.threads_leave(); is_gtk_locked = False
		
		for task_text, task_file in load_tasks():
			gtk.threads_enter(); is_gtk_locked = True
			if rows_to_forget.has_key(task_file):
				treeiter = rows_to_forget[task_file].iter
				del rows_to_forget[task_file]
			else:
				treeiter = tasklist.append(None, {})
			update_task_in_list(tasklist, treeiter, task_text, task_file)
			gtk.threads_leave(); is_gtk_locked = False
		
		loaded_file_path = add_path_prefix(RuntimeData.get('loaded-task-file'))
		for task_file, row in rows_to_forget.iteritems():
			gtk.threads_enter(); is_gtk_locked = True
			if loaded_file_path != task_file:
				tasklist.remove(row.iter)
			gtk.threads_leave(); is_gtk_locked = False
		for task_file, row in rows_to_forget.iteritems():
			gtk.threads_enter(); is_gtk_locked = True
			if loaded_file_path == task_file:
				# currently opened task is gone from the overall task list, close it
				act_close_task()
				tasklist.remove(row.iter)
			gtk.threads_leave(); is_gtk_locked = False
	finally:
		if not is_gtk_locked:
			gtk.threads_enter()
		tasklist_top_label1.remove_state(_("Loading notes…"))
		gtk.threads_leave()

def on_tasklist_changed(*X):
	timer_once(0.25, process_tasklist)
	on_tasklist_filtered_changed()

def on_tasklist_filtered_changed():
	tasklist_top_label2.set_text(_("Found: %d") % len(tasklist_filtered))

def sort_tags_by_count(tags):
	return sorted(tags, cmp=lambda a, b: cmp(b['count'], a['count']))

def make_tag_suggestion_list(tags):
	return sort_tags_by_count([{'label': '%s (%d)'%(key, tags[key]), 'word': key, 'count': tags[key]} for key in tags.keys()])

def count_tags(model, path, treeiter, data):
	task_text = model[path]['raw_text']
	for tag in get_tags(task_text):
		data[tag] = data.get(tag, 0) + 1

def process_tasklist():
	AllTags.clear()
	tasklist.foreach(count_tags, AllTags)

def save_position():
	filepath = add_path_prefix(RuntimeData.get('loaded-task-file'))
	saved_pos = RuntimeData.get('loaded-file-edit-position')
	pos = taskbody_buffer.cursor_pos
	if saved_pos != pos and filepath is not None and os.path.exists(filepath):
		ioQueue.put(('setxattr', [filepath, 'user.textedit.cursor_position', str(pos)], _("saving state…")))

def load_taskbody(text):
	save_position()
	taskbody_buffer.disable_events()
	taskbody_buffer.reinit(text)
	taskbody_buffer.enable_events()
	parse_taskbody(text)
	calendar.goto_today()

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[str(m)[0:3].lower()]
	except KeyError: pass
	return m

def find_markup_positions(text, markupname):
	def find_coderanges(text):
		# lines between 2 set of triple backticks, and
		# words embraced by backticks
		# (allow to escape first backtick with: r'(?<!\\)(?:\\\\)*`(.*?(?<!\\)(?:\\\\)*)`')
		for regex in r'^```[^\n]*\n(.*?)(?<=\n)```', r'(?<!\w)`([^\n]*?(?<!\\)(?:\\\\)*)`(?!\w)':
			for match in re.finditer(regex, text, re.S|re.M):
				yield match.start(1), match.end(1), []
	if markupname == 'headline':
		first_eol = text.find('\n')
		if first_eol > -1:
			yield 0, first_eol, []
		else:
			yield 0, len(text), []
	elif markupname == 'link':
		for match in re.finditer(r'\b([a-z+-]+://[^\s]+)', text, re.I):
			yield match.start(0), match.end(0), []
	elif markupname == 'strike':
		regex = u'^[ \t]*(?:-[ \t]*)?(.+?)([ \t]+(DONE|WONTFIX|OBSOLETED)|[ \t]*(✓|✔|✗|✘|\[(DONE|WONTFIX|OBSOLETED)\]))'
		for match in re.finditer(regex, text, re.U|re.M):
			yield match.start(1), match.end(1), []
	elif markupname in ['bold', 'alert']:
		coderanges = [(s, e) for s, e, h in find_coderanges(text)]
		if markupname == 'bold':
			# words embraced in asterisks, optionally surrounded by brackets or whitespace but nothing else
			for match in re.finditer(r'(^|[\s\(\[\{\<])\*(?!\s|\*)(.+?)(?<!\s|\*)\*(?=[\s\)\]\}\>]|$)', text):
				start, end = match.start(2), match.end(2)
				if all([end < s or start > e for s, e in coderanges]):
					yield start, end, [(start-1, start), (end, end+1)]
		elif markupname == 'alert':
			# a line ending in double exclamation marks, and literal string "<!>"
			for regex in r'^\s*(?:-\s*)?(.+!!)\s*$', r'(<!>)':
				for match in re.finditer(regex, text, re.M):
					start, end = match.start(1), match.end(1)
					if all([end < s or start > e for s, e in coderanges]):
						yield start, end, []
	elif markupname == 'code':
		for start, end, hideranges in find_coderanges(text):
			yield start, end, hideranges
	else:
		raise

def parse_taskbody(text):
	# style and format text
	taskbody_buffer.remove_all_tags()
	for markupname in ['headline', 'link', 'strike', 'bold', 'code', 'alert']:
		for start, end, hideranges in find_markup_positions(text, markupname):
			taskbody_buffer.apply_tag_by_name(markupname, start, end)
			for start, end in hideranges:
				taskbody_buffer.apply_tag_by_name('hidden', start, end)
	
	# find date strings and show them in calendar
	calendar_marks = []
	for y, m, d in re.findall(RE_DATE, text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + RE_MONTHNAMES + r')(?:-|\s+)(' + RE_DAYSOFMONTH + ')\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	if calendar_marks or re.search(r'\b(date|due):', text, re.I):
		if not calendar.get_visible():
			calendar.goto_today()
		calendar.show()
	else:
		calendar.hide()

def task_is_unsaved(unsaved=True):
	RuntimeData['unsaved'] = unsaved
	lbl = MarkupText("<span variant=\"smallcaps\" weight=\"bold\">"+_("not saved")+"</span>")
	if unsaved:
		tasklist_top_label1.add_state(lbl)
	else:
		tasklist_top_label1.remove_state(lbl)

def load_task(task_file_nonprefixed, task_text):
	act_close_task()
	load_taskbody(task_text)
	RuntimeData['loaded-task-file'] = task_file_nonprefixed
	task_is_unsaved(False)
	Props['history/last/opened-task/path'] = task_file_nonprefixed
	taskhistorylist.push(task_file_nonprefixed)
	# restore cursor position:
	filepath = add_path_prefix(task_file_nonprefixed)
	try:
		cursor_pos = xattr.getxattr(filepath, 'user.textedit.cursor_position')
	except IOError as e:
		if e.errno == errno.ENODATA: pass
		else: raise
	else:
		if cursor_pos is not None:
			cursor_pos = int(cursor_pos)
			taskbody_buffer.cursor_pos = cursor_pos
			act_taskbody_view_scroll_to_cursor()
			RuntimeData['loaded-file-edit-position'] = cursor_pos

def on_tasklist_selection_change(selection):
	model, iterpaths = selection.get_selected_rows()
	if len(iterpaths) == 0:
		return
	iterpath = iterpaths[0]
	# TODO: support multiple loaded tasks
	row = model[iterpath]
	loaded_task_file = add_path_prefix(RuntimeData.get('loaded-task-file'))
	if loaded_task_file is not None and loaded_task_file == row['file']:
		return
	load_task(strip_path_prefix(row['file']), row['raw_text'])

def timer_once(sec, func, func_args=(), keep_old_schedules=False, iden=None):
	if iden is None:
		iden = func.__name__
	if Timers.has_key(iden):
		if keep_old_schedules:
			return
		else:
			Timers[iden]['cancel']()
			# TODO: older schedules are still there, only the last one is cancelled
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
			'cancel': lambda: timer_cancel(iden),
		}

def timer_cancel(iden):
	if iden in Timers:
		glib.source_remove(Timers[iden]['handle'])
		del Timers[iden]

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def paced_action(delay, func, args=()):
	"call 'func' at least at a rate of 1 per 'delay' seconds"
	now = time.time()
	fname = func.__name__
	if fname not in Pacers:
		Pacers[fname] = {
			'func': func,
			'args': args,
		}
	last_run = Pacers[fname].get('last_run', 0)
	if last_run + delay < now:
		paced_action_call(fname)
	else:
		Pacers[fname]['func'] = func
		Pacers[fname]['args'] = args
		timer_once(last_run + delay - now, paced_action_call, (fname,), iden='paced_action:'+fname)

def paced_action_call(fname):
	Pacers[fname]['func'](*Pacers[fname]['args'])
	Pacers[fname]['last_run'] = time.time()

def on_searchbox_change(*X):
	timer_once(0.4, filter_tasklist)
	Props['field/search/text'] = searchbox.text

def on_searchbox_icon_clicked(entry, icon_pos, event):
	if icon_pos == 1:
		entry.text = ''

def successor_iter(model, predecessor):
	"""return the next "heir" in line of succession metaphorically speaking.
	i.e. the first child of the node if there is any, otherwise its next sibling node,
	otherwise its parent node's next sibling."""
	if model.iter_has_child(predecessor):
		return model.iter_nth_child(predecessor, 0)
	else:
		successor = model.iter_next(predecessor)
		if successor is None:
			while True:
				parent = model.iter_parent(predecessor)
				if parent is None: return None
				uncle = model.iter_next(parent)
				if uncle is not None: return uncle
				predecessor = parent
			return None
		return successor

def act_tasklist_select_updown(up=True):
	down = not up
	s_iter = None
	model, s_rows = tasklist_selection.get_selected_rows()
	if len(s_rows) == 0:
		c_iter = None
		s_iter = model.get_iter_root()
	else:
		c_iter = model.get_iter(s_rows[0 if up else -1])
	if c_iter is not None:
		if down:
			s_iter = successor_iter(model, c_iter) or c_iter
		elif up:
			predecessor = model.get_iter_root()
			while predecessor is not None:
				successor = successor_iter(model, predecessor)
				if successor is None:
					s_iter = model.get_iter_root()
					break
				if model.get_path(successor) == model.get_path(c_iter):
					s_iter = predecessor
					break
				predecessor = successor
	if s_iter is not None:
		tasklist_selection.unselect_all()
		tasklist_selection.select_iter(s_iter)
		tasklist_view.scroll_to_cell(model.get_path(s_iter))

def act_tasklist_select_prevnext(prev=True):
	if prev:
		task_file = taskhistorylist.backward()
	else:
		task_file = taskhistorylist.forward()
	if task_file is not None:
		select_or_load_task_by_file(task_file)

def on_searchbox_keypress(widget, event):
	keys = KeyDetector(event)
	shift_up = keys.up and keys.shift
	shift_down = keys.down and keys.shift
	if shift_up or shift_down:
		act_tasklist_select_updown(shift_up)
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			text, pos = replace_word(searchbox.get_text(), searchbox.get_property('cursor-position'), word, word_re=taskbody_word_re)
			searchbox.set_text(text)
			searchbox.set_position(pos)
		tab_completion_handled = handle_tab_completion(event, complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled
	if keys.enter:
		searchboxhistory.push(searchbox.text)
		timer_cancel('filter_tasklist')
		filter_tasklist()

def act_searchbox_prevnext(prev=True):
	if prev:
		text = searchboxhistory.backward()
	else:
		text = searchboxhistory.forward()
	if text is not None:
		searchbox.text = text

def replace_word(text, pos, word, word_re=None):
	first_half, second_half = get_word_halves(text, pos, word_re)
	new_pre = text[0:pos-len(first_half)] + word + ' '
	new_post = text[pos+len(second_half):]
	return (new_pre + new_post, len(new_pre))

def on_searchbox_keypressed(widget, event):
	query = searchbox.get_text()
	pos = searchbox.get_property('cursor-position')
	c_word = current_word(query, pos, word_re=taskbody_word_re)
	if c_word.startswith('#'):
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(c_word)
	else:
		completion_suggestions_box.hide()

def save_search_query(query):
	query = query.strip()
	if query != '' and query not in savedsearches.get_cells_by_column('query'):
		savedsearches.append(None, [query])

def on_savedsearches_changed(*X):
	timer_once(1.0, act_save_quicksearch_list)

def setup_savedsearches_editing():
	tvc = savedsearches_view.get_column_by_name('query')
	tvcr = tvc.get_cell_renderers()[0]
	tvcr.set_property('editable', True)
	tvcr.connect('edited', on_savedsearches_edit_cell, savedsearches, savedsearches.get_column_num('query'))

def on_savedsearches_edit_cell(tvcr, treepath, newcontent, treeview, column_num):
	if not newcontent:
		return False
	if type(treepath) == str:
		treepath = tuple(map(int, treepath.split(',')))
	treeview[treepath][column_num] = newcontent
	return True

def act_save_quicksearch_list():
	text = ''
	for row, query in savedsearches.walk_columns('query'):
		if query is None: continue
		expandstate = '+' if savedsearches_view.row_expanded(row.path) else '-'
		text += '\t'*(len(row.path)-1) + expandstate + query + '\n'
	Props['field/quicksearch/list'] = text

def load_saved_searches(savedsearches_text):
	prev_level = 0
	prev_iter_on_level = {-1: None}
	to_expand = []
	for tabs, expandstate, query in map(lambda s: re.findall(r'(\t*)([+-]?)(.*)', s)[0], savedsearches_text.split('\n')):
		if query == '': continue
		level = len(tabs)
		parent_iter = prev_iter_on_level[level - 1]
		prev_iter_on_level[level] = savedsearches.append(parent_iter, {'query': query})
		if expandstate == '+':
			to_expand.append(savedsearches.get_path(prev_iter_on_level[level]))
	for treepath in to_expand:
		savedsearches_view.expand_row(treepath, open_all=False)

def on_savedsearches_dnd_data(treeview, context, x, y, selectiondata, int_id, eventtime):
	if selectiondata.get_data_type() == 'text/plain':
		text = selectiondata.get_text()
		new_row = {'query': text}
		model = treeview.get_model()
		relative_row_path, drop_pos = treeview.get_dest_row_at_pos(x, y)
		relative_row = model.get_iter(relative_row_path)
		parent = model.iter_parent(relative_row)
		if drop_pos == gtk.TREE_VIEW_DROP_BEFORE:
			model.insert_before(parent, relative_row, new_row)
		elif drop_pos == gtk.TREE_VIEW_DROP_AFTER:
			model.insert_after(parent, relative_row, new_row)
		else:
			model.append(relative_row, new_row)
		context.finish(success=True, del_=False, time=eventtime)

def act_open_files(files):
	for filepath in files:
		run_async('mimeopen-gui', [filepath])

def on_savedsearches_menu(treeview, popup_menu, treepath, tv_col, cell_x, cell_y):
	mi = ActionStockMenuItem(label=_("Union Search"), stock_id=gtk.STOCK_SELECT_ALL, action=savedsearches_union_search)
	popup_menu.append(mi)
	mi = ActionStockMenuItem(label=_("Conjunct Search"), action=on_savedsearches_selection)
	popup_menu.append(mi)
	if treepath is not None:
		model = treeview.get_model()
		row = model[treepath]
		savedquery = row['query']
		mi = ActionStockMenuItem(label=_("Remove '%s'")%savedquery, stock_id=gtk.STOCK_REMOVE, \
			action=lambda Xwidget, model, row: model.remove(row.iter), action_userdata=(model, row))
		popup_menu.append(mi)

def savedsearches_union_search(*X):
	model, iterpaths = savedsearches_selection.get_selected_rows()
	if len(iterpaths) > 0:
		new_query = ', '.join([model[iterpath]['query'] for iterpath in iterpaths])
		searchbox.text = new_query
		searchboxhistory.push(new_query)

def on_savedsearches_selection(*X):
	# TODO: it is buggy when one of the queries is itself a union query
	model, iterpaths = savedsearches_selection.get_selected_rows()
	if len(iterpaths) > 0:
		new_query = ' '.join([model[iterpath]['query'] for iterpath in iterpaths])
		searchbox.text = new_query
		searchboxhistory.push(new_query)

def insert_treeview_column(treeview, coldef, base_col):
	add_treeview_columns(treeview, [coldef])
	tvc = treeview.get_columns()[-1]
	treeview.move_column_after(tvc, base_col)

def on_tasklist_header_menu(treeview, popup_menu, tvc):
	current_cols = dict([(col.get_name(), col) for col in treeview.get_columns()])
	for col_name, col in tasklist_view_columns_set.iteritems():
		if col_name not in current_cols:
			col_title, col_attr, col_num = col[:]
			mi = gtk.CheckMenuItem(col_title)
			mi.set_active(False)
			mi.connect('activate', lambda Xmi, coldef, base_tvc: insert_treeview_column(treeview, coldef, base_tvc), [col_name, col_title, col_attr, col_num], tvc)
			popup_menu.append(mi)
	for col_name, col in current_cols.iteritems():
		col_title, col_attr, col_num = tasklist_view_columns_set[col_name][:]
		markup = glib.markup_escape_text(col_title)
		if tvc.get_name() == col_name:
			markup = '<b>' + markup + '</b>'
		mi = CheckMenuItem(markup=markup)
		mi.set_active(True)
		if len(current_cols) > 1:
			mi.connect('activate', lambda Xmi, col: treeview.remove_column(col), col)
		popup_menu.append(mi)

def on_tasklist_menu(treeview, popup_menu, c_treepath, tv_col, cell_x, cell_y):
	popup_menu.append(ActionStockMenuItem(label=_("New task"), stock_id=gtk.STOCK_NEW, action=lambda *X: act_new_task()))	
	if c_treepath is not None:
		model, s_treepaths = tasklist_selection.get_selected_rows()
		selected_filepaths = []
		for s_treepath in s_treepaths:
			selected_filepaths.append(model[s_treepath]['file'])
		clicked_filepath = model[c_treepath]['file']
		selected_or_clicked_filepaths = selected_filepaths or [clicked_filepath]
		popup_menu.append(gtk.SeparatorMenuItem())
		if len(selected_or_clicked_filepaths) > 1: menuitem_label_suffix_open_externally = " (%d)" % len(selected_or_clicked_filepaths)
		else: menuitem_label_suffix_open_externally = ''
		popup_menu.append(ActionStockMenuItem(label=_("Open externally%s")%menuitem_label_suffix_open_externally, stock_id=gtk.STOCK_OPEN, action=lambda *X: act_open_files(selected_or_clicked_filepaths)))
		popup_menu.append(ActionStockMenuItem(label=_("Done this"), stock_id=gtk.STOCK_APPLY, action=lambda *X: act_task_done([clicked_filepath])))
		if len(selected_filepaths) > 1:
			popup_menu.append(ActionStockMenuItem(label=_("Done selected (%d)")%len(selected_filepaths), stock_id=gtk.STOCK_APPLY, action=lambda *X: act_task_done(selected_filepaths)))
		popup_menu.append(ActionStockMenuItem(label=_("Delete this…"), stock_id=gtk.STOCK_DELETE, action=lambda *X: act_task_delete([clicked_filepath])))

def act_open_selected_tasks(*X):
	model, s_treepaths = tasklist_selection.get_selected_rows()
	selected_filepaths = []
	for s_treepath in s_treepaths:
		selected_filepaths.append(model[s_treepath]['file'])
	act_open_files(selected_filepaths)

def on_tasklist_dnd_drop(treeview, context, x, y, eventtime):
	within_drop_region = True
	return within_drop_region

def on_tasklist_dnd_data(treeview, context, x, y, selectiondata, int_id, eventtime):
	datatype = selectiondata.get_data_type()
	if datatype == 'text/plain':
		text = selectiondata.get_text()
		act_new_task()
		taskbody_buffer.set_text(text)
		context.finish(success=True, del_=False, time=eventtime)
	else:
		sys.stderr.write((_("Unsupported Drag-and-Drop data type: '%s'")+'\n') % datatype)
	# call stop_emission() to prevent the following warning:
	# > GtkWarning: You must override the default 'drag_data_received' handler on GtkTreeView when using models that don't support the GtkTreeDragDest interface and enabling drag-and-drop.
	treeview.stop_emission('drag_data_received')
	return True

def on_taskbody_dnd_data(textview, context, x, y, selectiondata, int_id, eventtime):
	datatype = selectiondata.get_data_type()
	if datatype == 'text/uri-list':
		uris = []
		for uri in selectiondata.get_uris():
			home = os.path.expanduser('~/')
			uri = uri.replace('file://'+home, 'file://~/')
			uris.append(uri)
		if len(uris) == 1:
			text = uris[0]
		else:
			text = '\n'.join(uris) + '\n'
		textiter = textview_get_iter_from_window_widget_coordinates(textview, x, y)
		taskbody_buffer.insert(textiter, text)
		return True

def act_task_done(filepaths):
	for filepath in filepaths:
		subpath = strip_path_prefix(filepath)
		subdir, subfile = os.path.split(subpath)
		newpath = find_nonexistent_file(os.path.join(NOTES_ARCHIVE_DIR, subdir), subfile)
		ioQueue.put(('mkdir', [os.path.dirname(newpath)], _("saving note…")))
		act_close_task()
		ioQueue.put(('rename', [filepath, newpath], _("saving note…")))

def act_task_delete(filepaths):
	for filepath in filepaths:
		if question(_("Really delete?")+'\n<tt>'+glib.markup_escape_text(filepath)+'</tt>', stock_yes=(None, gtk.STOCK_DELETE), stock_no=(None, gtk.STOCK_CANCEL), parent=main_win):
			act_close_task()
			ioQueue.put(('remove', [filepath], _("remove note…")))

def make_tasklist_sortkey(cell, order):
	"""let the alphabetical cells always first, numeric cells second,
	and empty cells be the last part, regardless of the ascending/descending order
	which only applies within each groups"""
	if order == gtk.SORT_ASCENDING:
		if cell == '' or cell is None: sortkey = 'C'
		elif re.search(r'^\d', cell): sortkey = 'B'
		else: sortkey = 'A'
	else:
		if cell == '' or cell is None: sortkey = 'A'
		elif re.search(r'^\d', cell): sortkey = 'B'
		else: sortkey = 'C'
	sortkey += cell or ''
	return sortkey

def tasklist_sort_callback(model, iter_a, iter_b, cb_data):
	cell_a = model[iter_a][cb_data['col_num']]
	cell_b = model[iter_b][cb_data['col_num']]
	col_id, order = cb_data['sort_model'].get_sort_column_id()
	sortkey_a = make_tasklist_sortkey(cell_a, order)
	sortkey_b = make_tasklist_sortkey(cell_b, order)
	return cmp(sortkey_a, sortkey_b)

def filter_tasklist():
	tasklist_filtered.refilter()
	on_tasklist_filtered_changed()
	
	if completion_suggestions_box.get_visible():
		query = searchbox.text
		pos = searchbox.get_property('cursor-position')
		# count each tags how many task would be there if we would add the suggested tag to the search filter
		# TODO: it's sometimes expensive
		def count_tags_making_intersection(model, treepath, treeiter, completion_items):
			for item in completion_items:
				newquery, Xpos = replace_word(query, pos, item['word'], word_re=taskbody_word_re)
				include = tasklist_filterer_with_custom_query(model, treeiter, newquery)
				if include: item['count'] += 1
		completion_items = list([{'word': key, 'count': 0} for key in AllTags.keys()])
		tasklist_view.get_model().foreach(count_tags_making_intersection, completion_items)
		completion_items = filter(lambda item: item['count']>0, completion_items)
		map(lambda item: item.update({'label': '%s (%d)'%(item['word'], item['count'])}), completion_items)
		completion_items = sort_tags_by_count(completion_items)
		completion_suggestions_box.set_items(completion_items)

def tasklist_filterer(model, treeiter):
	query = searchbox.text
	query = query.strip()
	return tasklist_filterer_with_custom_query(model, treeiter, query)

def noaccent(s):
	return unicodedata.normalize('NFKD', s).encode('ASCII', 'ignore')

def tasklist_filterer_with_custom_query(model, treeiter, query):
	if query == '':
		return True
	task_text_noaccent = model[treeiter]['noaccent_text']
	query_match = False
	if task_text_noaccent is not None:
		task_text_all_lower = task_text_noaccent.lower()
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					
					# report match if the task does not have any tag
					if query_word == 'NOTAG':
						notag = not bool(get_tags(task_text_noaccent))
						if (positive_match and not notag) or (not positive_match and notag):
							alternative_match = False
							break
						continue
					
					# report match if the task's directory name matches to the query word
					spec_file = re.match(r'path:(.+)', query_word)
					if spec_file:
						query_word = spec_file.group(1)
						path = os.path.dirname(strip_path_prefix(model[treeiter]['file']))
						# match to path names always case-insensitively
						query_word = query_word.lower()
						path = path.lower()
						word_match = path.find(query_word) > -1
					else:
						query_word = noaccent(query_word)
						
						# match case-insensitively if the query word is all lowercase, and case-sensitively otherwise
						if query_word.lower() == query_word:
							task_text_smartcase = task_text_all_lower
						else:
							task_text_smartcase = task_text_noaccent
						
						# do the substring matching
						word_match = task_text_smartcase.find(query_word) > -1
					
					# evaluate the match result
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
					
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def get_tasklist_treeiter_by_file(q_file):
	treeiter = None
	for c_row, c_file in tasklist.walk_columns('file'):
		if c_file == q_file:
			return c_row.iter
	raise KeyError(_("No row with file=='%s'") % q_file)

def save_file_asap(fullpath, text):
	ioQueue.put(('write', [fullpath, text], _("saving note…")))
	# although it probably has not touched the disk yet, but in the main thread's PoV it's considered saved,
	# because we don't need to fire a save operation again, as the IO thread will do it eventually. at the
	# worst case at the exit.
	task_is_unsaved(False)

def on_taskbody_changed(*X):
	task_is_unsaved()
	text = taskbody_buffer.get_text_all()
	parse_taskbody(text)
	auto_save_task()

def auto_save_task():
	text = taskbody_buffer.get_text_all()
	loaded_task_file = RuntimeData.get('loaded-task-file')
	if loaded_task_file is None:
		# don't save new task until at least one line is entered,
		# and generate file name from the first line
		m = re.search(r'^\s*(.+?)\n', text)
		if not m: return
		first_line = m.group(1)
		filepath = find_nonexistent_file(NOTES_DIR, filenameize(first_line) + '.txt')
		RuntimeData['loaded-task-file'] = strip_path_prefix(filepath)
	
	loaded_task_file = RuntimeData.get('loaded-task-file')
	loaded_task_file_fqp = add_path_prefix(loaded_task_file)
	try:
		treeiter = get_tasklist_treeiter_by_file(loaded_task_file_fqp)
	except KeyError:
		# new file has not been noticed yet (async IO is being slow)
		pass
	else:
		update_task_in_list(tasklist, treeiter, task_text=text, task_mtime=time.time())
	# save but not too frequently
	paced_action(5.0, save_file_asap, (loaded_task_file_fqp, text))

def on_taskbody_typing(textbuffer, textiter, typedtext, length):
	first_half, second_half = textbuffer.get_word_halves(textiter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def on_taskbody_erase(textbuffer, startiter, enditer):
	first_half = textbuffer.get_word_halves(startiter, word_re=taskbody_word_re)[0]
	second_half = textbuffer.get_word_halves(enditer, word_re=taskbody_word_re)[1]
	c_word = first_half+second_half
	act_taskbody_word(c_word, len(first_half))

def act_taskbody_word(word, pos):
	if word.startswith('#') and pos>0:
		completion_suggestions_box.show()
		completion_suggestions_box.filter_for(word)
	else:
		completion_suggestions_box.hide()

def act_change_font(*X):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(main_win)
	dlg.set_modal(True)
	dlg.set_font_name(Props['field/taskbody/font'] or textview_get_current_font(taskbody_view)['name'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['field/taskbody/font'] = font_name
		taskbody_view_set_font(font_name)
	dlg.destroy()

def textview_get_current_font(textview):
	pctx = textview.get_pango_context()
	fdsc = pctx.get_font_description()
	return {'name': fdsc.to_string(), 'size': int(fdsc.get_size()/pango.SCALE)}

def taskbody_view_set_font(fontname):
	taskbody_view.modify_font(pango.FontDescription(fontname))
	fontsize = textview_get_current_font(taskbody_view)['size']
	head_tag = taskbody_buffer.get_tag_by_name('headline')
	head_tag.set_property('pixels-below-lines', int(fontsize * 0.8))

def taskbody_view_toggle_wrap(*X):
	wrap_mode = 'WRAP_NONE' if taskbody_view.get_wrap_mode() != gtk.WRAP_NONE else 'WRAP_WORD'
	taskbody_view.set_wrap_mode(getattr(gtk, wrap_mode))
	Props['field/taskbody/wrapmode'] = wrap_mode

def on_taskbody_view_click(textview, event):
	textview.set_data('pointed-word', None)
	textiter = textview_get_iter_from_window_widget_coordinates(textview, event.x, event.y)
	word = textview.get_buffer().get_word(textiter, word_re=taskbody_word_re)
	textview.set_data('pointed-word', word)

def on_taskbody_view_menu(Xtextview, menu):
	pos = 0
	
	mi = ActionStockMenuItem(label=_("New task"), stock_id=gtk.STOCK_NEW, action=act_new_task)
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	
	has_selection = taskbody_buffer.get_has_selection()
	pointed_word = taskbody_view.get_data('pointed-word')
	if has_selection or pointed_word:
		if has_selection:
			mi_label_suffix = ' ' + _("selected")
		elif pointed_word:
			mi_label_suffix = ' \'%s\'' % pointed_word
		else:
			mi_label_suffix = ''
		mi = ActionStockMenuItem(label=_("Search")+mi_label_suffix, stock_id=gtk.STOCK_FIND, action=act_search_text)
		menu.insert(mi, pos)
		pos += 1
		mi = ActionStockMenuItem(label=_("Refine Search"), stock_id=gtk.STOCK_FIND, action=act_refine_search)
		menu.insert(mi, pos)
		pos += 1
	if RuntimeData.get('loaded-task-file') is not None:
		opened_file = add_path_prefix(RuntimeData.get('loaded-task-file'))
		mi = ActionStockMenuItem(label=_("Done this task"), stock_id=gtk.STOCK_APPLY, action=lambda Xwidget, opened_file: act_task_done([opened_file]), action_userdata=(opened_file,))
		menu.insert(mi, pos)
		pos += 1
	
	mi = ActionStockMenuItem(label=_("Default Font…"), stock_id=gtk.STOCK_SELECT_FONT, action=act_change_font)
	menu.insert(mi, pos)
	pos += 1
	
	mi = gtk.CheckMenuItem(label=_("Wrap Lines"))
	mi.set_active(taskbody_view.get_wrap_mode() != gtk.WRAP_NONE)
	mi.connect('toggled', taskbody_view_toggle_wrap)
	menu.insert(mi, pos)
	pos += 1
	
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	menu.show_all()

def get_taskbody_selected_or_pointed_text():
	if taskbody_buffer.get_has_selection():
		return taskbody_buffer.get_selected_text()
	else:
		return taskbody_view.get_data('pointed-word')
def act_search_text(*X):
	searchbox.text = get_taskbody_selected_or_pointed_text()
	searchboxhistory.push(searchbox.text)
def act_refine_search(*X):
	searchbox.text += ' ' + get_taskbody_selected_or_pointed_text()
	searchboxhistory.push(searchbox.text)

class KeyDetector(object):
	def __init__(self, event):
		self.tab = False
		self.backtab = False
		self.control = event.state & gtk.gdk.CONTROL_MASK != 0
		self.shift = event.state & gtk.gdk.SHIFT_MASK != 0
		self.alt = event.state & gtk.gdk.MOD1_MASK != 0
		if not self.control and not self.alt:
			self.tab = event.keyval == gtk.gdk.keyval_from_name('Tab') and not self.shift
			self.backtab = (event.keyval == gtk.gdk.keyval_from_name('Tab') and self.shift) or event.keyval == gtk.gdk.keyval_from_name('ISO_Left_Tab')
		self.enter = event.keyval in [gtk.gdk.keyval_from_name('Return'), gtk.gdk.keyval_from_name('Enter')]
		self.escape = event.keyval == gtk.gdk.keyval_from_name('Escape')
		self.up = event.keyval == gtk.gdk.keyval_from_name('Up')
		self.down = event.keyval == gtk.gdk.keyval_from_name('Down')
		for letter in map(chr, range(ord('a'), ord('z')+1)):
			setattr(self, letter.upper(), event.keyval == gtk.gdk.keyval_from_name(letter))

def handle_tab_completion(event, callback):
	keys = KeyDetector(event)
	if keys.tab:
		completion_suggestions_box.next_suggestion()
		return True  # prevent event propagation
	elif keys.backtab:
		completion_suggestions_box.previous_suggestion()
		return True
	elif keys.control and keys.enter:
		suggestion = completion_suggestions_box.current_suggestion_word
		if suggestion is not None:
			callback(suggestion)
			completion_suggestions_box.hide()
			return True
	return None

def on_taskbody_view_keypress(widget, event):
	keys = KeyDetector(event)
	if completion_suggestions_box.get_visible():
		def complete_word(word):
			taskbody_buffer.replace_current_word(word+' ', word_re=taskbody_word_re)
		tab_completion_handled = handle_tab_completion(event, callback=complete_word)
		if tab_completion_handled is not None:
			return tab_completion_handled
	
	if keys.escape:
		completion_suggestions_box.hide()
		return True
	if keys.tab or keys.backtab:
		selected_text = taskbody_buffer.get_selected_text()
		if selected_text != '':
			if keys.tab:
				selected_text = re.sub(r'^(?=.)', '\t', selected_text, flags=re.M)
			elif keys.backtab:
				selected_text = re.sub(r'^\t', '', selected_text, flags=re.M)
			taskbody_buffer.replace_selected_text(selected_text)
		else:
			if keys.tab:
				return False
			elif keys.backtab:
				line = taskbody_buffer.get_current_line()
				if line.startswith('\t'):
					sol, Xeol = taskbody_buffer.get_current_line_boundaries()
					taskbody_buffer.delete(taskbody_buffer.get_iter_at_offset(sol), taskbody_buffer.get_iter_at_offset(sol+1))
		return True
	if keys.control:
		if keys.enter:
			text = taskbody_buffer.get_text_all()
			pos = taskbody_buffer.cursor_pos
			for start, end, Xhideranges in find_markup_positions(text, 'link'):
				if start <= pos < end:
					link = taskbody_buffer.get_text_all()[start:end]
					if link.startswith('file://'):
						link = os.path.expanduser(link[7:])
						link = urllib2.unquote(link)
					run_async('xdg-open', [link])
					return True
			c_word = current_word(text, pos, word_re=taskbody_word_re)
			if c_word.startswith('#'):
				searchbox.text = searchbox.text + ' ' + c_word
				return True
			c_date = re.search(RE_DATE, current_word(text, pos, word_re=r'[0-9a-z-]'), re.I)
			if c_date:
				y, m, d = map(int, c_date.groups())
				calendar.goto(y, month_name_to_number(m), d)
				return True
		elif keys.B:
			s = taskbody_buffer.get_selected_text()
			if s.startswith('*') and s.endswith('*') and len(s)>2:
				s = s[1:-1]
			else:
				s = '*' + s + '*'
			taskbody_buffer.replace_selected_text(s)
			return True
		elif keys.Y or (keys.Z and keys.shift):
			taskbody_buffer.redo()
			act_taskbody_view_scroll_to_cursor()
			return True
		elif keys.Z:
			taskbody_buffer.undo()
			act_taskbody_view_scroll_to_cursor()
			return True
	if keys.alt and keys.T:
		taskbody_buffer.insert_at_cursor(time.strftime('%Y-%m-%d'))
		return True

def act_taskbody_view_scroll_to_cursor():
	taskbody_view.scroll_to_mark(taskbody_buffer.get_insert(), within_margin=0.33)

def on_taskbody_view_cursor_moved(Xtextview, Xstep_size, Xcount, Xextend_selection):
	first_half, second_half = taskbody_buffer.get_word_halves(taskbody_buffer.cursor_iter, word_re=taskbody_word_re)
	act_taskbody_word(first_half + second_half, len(first_half))

def on_taskbody_view_focus(*X):
	completion_items = make_tag_suggestion_list(AllTags)
	completion_suggestions_box.set_items(completion_items)

def taskbody_insert_line(s):
	pre, post = taskbody_buffer.get_buffer_halves()
	can_surround_chars = ['\n', ' ', '\t', ':', ',', ';']
	if pre[-1] not in can_surround_chars: s = '\n' + s
	if post == '' or post[0] not in can_surround_chars: s = s + '\n'
	taskbody_buffer.insert_at_cursor(s)

def taskbody_remove_text_around_cursor(s):
	"""removes first occurrance of s from taskbody_buffer before the cursor
	or after the cursor, whichever is the nearest.
	removes newline if s is a complete line."""
	pre, post = taskbody_buffer.get_buffer_halves()
	pre_pos = (pre+post).rfind(s, 0, len(pre)+len(s)-2)
	post_pos = post.find(s)
	if pre_pos > -1 and post_pos > -1:
		pre_distance = len(pre) - pre_pos - len(s)
		post_distance = post_pos
		if post_distance < pre_distance:
			remove_from_pos = len(pre)+post_pos
		else:
			remove_from_pos = pre_pos
	elif post_pos > -1:
		remove_from_pos = len(pre)+post_pos
	elif pre_pos > -1:
		remove_from_pos = pre_pos
	else:
		return False
	remove_length = len(s)
	if (remove_from_pos > 0 and (pre+post)[remove_from_pos-1] == '\n' or remove_from_pos == 0) and remove_from_pos+len(s) < len(pre+post) and (pre+post)[remove_from_pos+len(s)] == '\n':
		remove_length = remove_length + 1
	taskbody_buffer.replace_text(remove_from_pos, remove_length, '')

def act_close_task():
	save_position()
	if RuntimeData.get('unsaved'):
		auto_save_task()
	RuntimeData['loaded-task-file'] = None
	RuntimeData['loaded-file-edit-position'] = None
	taskbody_buffer.reinit('')

def act_new_task(*_X):
	act_close_task()
	tasklist_selection.unselect_all()
	taskbody_view.grab_focus()


HelpWindow = gtk.MessageDialog(None, gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_OK)
HelpWindow.set_markup("""<b>Ctrl-F</b>, <b>Ctrl-L</b> focus on search box
<b>Ctrl-T</b> focus on the note
<b>Ctrl-N</b> new note

<b>Ctrl-S</b> save current search term in quick search list
<b>F4</b> open selected note externally
<b>Ctrl-Shift-W</b> toggle text wrap mode
<b>Ctrl-Shift-L</b> change window layout
<b>Ctrl-Q</b> quit

<b>Ctrl-P</b> bring back previous search term
<b>Ctrl-Shift-P</b> bring back next search term
<b>Meta ↑</b> select previous note in the list
<b>Meta ↓</b> select next note in the list
<b>Meta ←</b> bring back previously viewed note
<b>Meta →</b> bring back next viewed note
""")
HelpWindow.set_title(_("Help"))
HelpWindow.set_modal(False)
for sgnl in 'delete-event', 'close', 'response':
	HelpWindow.connect(sgnl, lambda *X: (HelpWindow.hide(), True)[1])
del sgnl



Timers = {}
Pacers = {}
Props = PropertyTree()
RuntimeData = {}
AllTags = {}
ioQueue = Queue.Queue()

def on_io_work(state, task, exception=None):
	gtk.threads_enter()
	Xoper, Xparams, message = task
	assert state in ('start', 'finish', 'error')
	if state == 'start':
		tasklist_top_label1.add_state(message)
	elif state == 'finish':
		tasklist_top_label1.remove_state(message)
	elif state == 'error':
		tasklist_top_label1.remove_state(message)
		traceback.print_exception(*exception)
		display_error(exception[1])
	gtk.threads_leave()

class ioWorker(threading.Thread):
	def __init__(self, queue, status_callback):
		super(self.__class__, self).__init__()
		self._queue = queue
		self._status_callback = status_callback
	def run(self):
		while True:
			task = self._queue.get()
			oper, params, cb_data = task[:]
			if oper == 'exit':
				self._queue.task_done()
				break
			self._status_callback('start', task)
			try:
				getattr(self, 'op_'+oper)(*params)
			except:
				self._status_callback('error', task, sys.exc_info())
			else:
				self._status_callback('finish', task)
			self._queue.task_done()
	def op_mkdir(self, path):
		mkdir(path)
	def op_write(self, path, content):
		with open(path, 'w') as f:
			f.write(content)
	def op_rename(self, oldpath, newpath):
		os.rename(oldpath, newpath)
	def op_remove(self, path):
		os.remove(path)
	def op_setxattr(self, path, attrname, attrval):
		xattr.setxattr(path, attrname, attrval)



if do_create_notes_dir and not os.path.exists(NOTES_DIR):
	mkdir(NOTES_DIR)


ioThread = ioWorker(ioQueue, on_io_work)
ioThread.start()
tasklist_loader = TasklistLoader()
tasklist_loader.daemon = True
tasklist_loader.start()


main_win = gtk.Window()
paned1 = gtk.HPaned()
paned2h = gtk.HPaned()
paned2v = gtk.VPaned()

main_win.set_title('μNote')
main_win.set_icon(gtk.icon_theme_get_default().load_icon('accessories-text-editor', gtk.ICON_SIZE_SMALL_TOOLBAR, 0))

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2h.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass
try: paned2v.set_position(*map(int, getprops('layout/panel/tasklist/height')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2h.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))
paned2v.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/height', paned.get_position())))

savedsearches = TreeStore(('query', unicode))
savedsearches.connect('changed', on_savedsearches_changed)
savedsearches_view = TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [('query', _("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(False)
savedsearches_view.connect('menu-popup', on_savedsearches_menu)
savedsearches_view.connect('row-collapsed', on_savedsearches_changed)
savedsearches_view.connect('row-expanded', on_savedsearches_changed)
savedsearches_view.drag_dest_set(gtk.DEST_DEFAULT_HIGHLIGHT, [('text/plain', 0, 0), ('GTK_TREE_MODEL_ROW', 0, 1)], gtk.gdk.ACTION_COPY)
savedsearches_view.connect('drag-data-received', on_savedsearches_dnd_data)
setup_savedsearches_editing()
load_saved_searches(Props['field/quicksearch/list'] or '')

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)
savedsearches_selection.connect('changed', on_savedsearches_selection)

searchbox = TextEntry()
searchbox.text = Props.get('field/search/text', '')
searchbox.set_icon_from_stock(1, gtk.STOCK_CLEAR)
searchbox.set_tooltip_markup(_("""Search expressions:\n
<b><tt>peanut</tt></b> – tasks containing substring "peanut" even in word fragments
<b><tt>#peanut</tt></b> – tasks containing a tag starting with "#peanut"
<b><tt>apple pear</tt></b> – tasks containing both "apple" and "pear" as well
<b><tt>apple, pear</tt></b> – all tasks containing "apple" or "pear" or both
<b><tt>apple NOT pear peach</tt></b> – tasks containing apple but neither pear nor peach
<b><tt>NOTAG</tt></b> – tasks lacking of any tag
<b><tt>NOT NOTAG</tt></b> – task having any tag
<b><tt>path:intake</tt></b> – tasks which are in a file on the filesystem which path matches to "intake" (ignoring μNotes base path and the file name itself)"""))
searchbox.connect('changed', on_searchbox_change)
searchbox.connect('key-press-event', on_searchbox_keypress)
searchbox.connect('key-release-event', on_searchbox_keypressed)
searchbox.connect('icon-release', on_searchbox_icon_clicked)

taskhistorylist = HistoryList(items=nulsplit(Props['history/opened-tasks']), pointer=int(Props['history/opened-task-pointer'] or -1))
taskhistorylist.on_change = lambda: (Props.__setitem__('history/opened-tasks', chr(0).join(taskhistorylist[:])), Props.__setitem__('history/opened-task-pointer', str(taskhistorylist.pointer)))

searchboxhistory = HistoryList(items=nulsplit(Props['history/search-terms']), pointer=int(Props['history/search-terms-pointer'] or -1))
searchboxhistory.on_change = lambda: (Props.__setitem__('history/search-terms', chr(0).join(searchboxhistory[:])), Props.__setitem__('history/search-terms-pointer', str(searchboxhistory.pointer)))

directory_watcher = inotifyx.init()
inotifyx.add_watch(directory_watcher, NOTES_DIR, inotifyx.IN_CREATE | inotifyx.IN_DELETE | inotifyx.IN_MOVE)
glib.io_add_watch(directory_watcher, glib.IO_IN|glib.IO_OUT, on_notes_dir_changed)

tasklist = TreeStore(('headline_markup', unicode), ('raw_text', unicode), ('noaccent_text', str), ('file', unicode), ('created', str), ('updated', str), ('date', str), ('due', str))
tasklist.connect('set-changed', on_tasklist_changed)

tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)
tasklist_sorted = TreeModelSort(tasklist_filtered)
for col_name in 'date', 'due':
	col_num = tasklist.get_column_num(col_name)
	tasklist_sorted.set_sort_func(col_num, tasklist_sort_callback, {'col_name': col_name, 'col_num': col_num, 'sort_model': tasklist_sorted})
tasklist_sorted.set_sort_column_id(tasklist.get_column_num(Props.get('field/tasklist/sort-by', 'due')), int(Props.get('field/tasklist/sort-order', gtk.SORT_ASCENDING)))

tasklist_top = gtk.HBox()
tasklist_top_label1 = StatusLabel()
tasklist_top_label2 = gtk.Label()
tasklist_top_label2.set_alignment(1, 0)
tasklist_top.pack_start(tasklist_top_label1, expand=True)
tasklist_top.pack_start(tasklist_top_label2, expand=False)

tasklist_view = TreeView(tasklist_sorted)
tasklist_view_columns_set = {
	'headline_markup': [_("Task"), 'markup', tasklist.get_column_num('headline_markup')],
	'created': [_("Created"), 'text', tasklist.get_column_num('created')],
	'updated': [_("Updated"), 'text', tasklist.get_column_num('updated')],
	'due': [_("Due"), 'text', tasklist.get_column_num('due')],
	'date': [_("Date"), 'text', tasklist.get_column_num('date')],
}
tasklist_view_columns_display_init = []
for col_name in (Props['layout/panel/tasklist/columns-order'] or 'headline_markup\ncreated\nupdated\ndue\ndate').strip().split('\n'):
	col = tasklist_view_columns_set[col_name][:]
	col.insert(0, col_name)
	tasklist_view_columns_display_init.append(col)
	del col
add_treeview_columns(tasklist_view, tasklist_view_columns_display_init)
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)
tasklist_view.connect('menu-popup', on_tasklist_menu)
tasklist_view.connect('header-menu-popup', on_tasklist_header_menu)
tasklist_view.connect('columns-changed', lambda treeview: Props.__setitem__('layout/panel/tasklist/columns-order', '\n'.join(map(lambda tvc: tvc.get_name(), treeview.get_columns()))))
tasklist_view.drag_dest_set(gtk.DEST_DEFAULT_HIGHLIGHT | gtk.DEST_DEFAULT_DROP, [('text/plain', 0, 0)], gtk.gdk.ACTION_COPY)
tasklist_view.connect('drag-drop', on_tasklist_dnd_drop)
tasklist_view.connect('drag-data-received', on_tasklist_dnd_data)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

taskbody_buffer = TextBuffer()
taskbody_buffer.connect('changed', on_taskbody_changed)
taskbody_buffer.connect_after('insert-text', on_taskbody_typing)
taskbody_buffer.connect('delete-range', on_taskbody_erase)

taskbody_view = gtk.TextView(buffer=taskbody_buffer)
taskbody_view_set_font(Props['field/taskbody/font'] or '')
taskbody_view.set_wrap_mode(getattr(gtk, Props['field/taskbody/wrapmode'] or 'WRAP_WORD'))
taskbody_view.connect('button-press-event', on_taskbody_view_click)
taskbody_view.connect('populate-popup', on_taskbody_view_menu)
taskbody_view.connect('key-press-event', on_taskbody_view_keypress)
taskbody_view.connect_after('move-cursor', on_taskbody_view_cursor_moved)
taskbody_view.connect('focus-in-event', on_taskbody_view_focus)
taskbody_view.drag_dest_set(gtk.DEST_DEFAULT_HIGHLIGHT, [('text/uri-list', 0, 0), ('text/plain', 0, 1)], gtk.gdk.ACTION_LINK)
taskbody_view.connect('drag-data-received', on_taskbody_dnd_data)

completion_suggestions_box = CompletionSuggestionsBox()

calendar = Calendar()
calendar.connect('mark-added', lambda X, date: taskbody_insert_line(date))
calendar.connect('mark-removed', lambda X, date: taskbody_remove_text_around_cursor(date))

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
add_key_binding(main_win, '<Control>f', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>l', lambda *X: searchbox.grab_focus())
add_key_binding(main_win, '<Control>s', lambda *X: save_search_query(searchbox.text))
add_key_binding(main_win, '<Control>p', lambda *X: act_searchbox_prevnext(prev=True))
add_key_binding(main_win, '<Control><Shift>p', lambda *X: act_searchbox_prevnext(prev=False))
add_key_binding(main_win, '<Mod1>Up', lambda *X: act_tasklist_select_updown(up=True))
add_key_binding(main_win, '<Mod1>Down', lambda *X: act_tasklist_select_updown(up=False))
add_key_binding(main_win, '<Mod1>Left', lambda *X: act_tasklist_select_prevnext(prev=True))
add_key_binding(main_win, '<Mod1>Right', lambda *X: act_tasklist_select_prevnext(prev=False))
add_key_binding(main_win, '<Control>t', lambda *X: taskbody_view.grab_focus())
add_key_binding(main_win, '<Control>n', lambda *X: act_new_task())
add_key_binding(main_win, '<Control><Shift>l', lambda *X: do_layout(LAYOUT[(LAYOUT.index(Props['layout/layout-set'])+1)%len(LAYOUT)]))
add_key_binding(main_win, '<Control><Shift>w', taskbody_view_toggle_wrap)
add_key_binding(main_win, 'F4', act_open_selected_tasks)
add_key_binding(main_win, 'F1', lambda *X: (HelpWindow.hide(), HelpWindow.show_all()))  # hide and show raises the window most reliably
main_win.connect('delete-event', lambda *X: main_quit())


box_main = gtk.HBox()
main_win.add(box_main)
box_savedsearches = ScrolledWidget(savedsearches_view)
box_tasklist = gtk.VBox()
box_tasklist.pack_start(searchbox, expand=False)
box_tasklist.pack_start(tasklist_top, expand=False)
box_tasklist.pack_start(ScrolledWidget(tasklist_view))
box_bottom = gtk.HBox()
box_taskview = gtk.VBox()
box_taskview.pack_start(ScrolledWidget(taskbody_view))
box_taskview.pack_start(completion_suggestions_box, expand=False)
box_auxtools = gtk.VBox()
box_auxtools.pack_start(calendar)

LAYOUT = ['3COL', '2COL1ROW', '1COL2ROW']
def do_layout(layout):
	def unpack(w):
		p = w.get_parent()
		if p is not None:
			p.remove(w)
	
	unpack(paned1)
	unpack(paned2h)
	unpack(paned2v)
	unpack(box_savedsearches)
	unpack(box_tasklist)
	unpack(box_bottom)
	unpack(box_taskview)
	unpack(box_auxtools)
	
	if layout not in LAYOUT:
		sys.stderr.write("Unknown layout '%s', fallback to default\n" % layout)
		layout = '3COL'
	
	if layout == '3COL':
		"""
		+--+--+--+
		|  |  |  |
		|  |  |  |
		|  |  |  |
		+--+--+--+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2h)
		paned2h.pack1(box_tasklist)
		paned2h.pack2(box_taskview)
		box_taskview.pack_start(box_auxtools, expand=False)
	elif layout == '2COL1ROW':
		"""
		+--+---+
		|  |   |
		+--+---+
		|      |
		+------+
		"""
		box_main.pack_start(paned2v)
		paned2v.pack1(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	elif layout == '1COL2ROW':
		"""
		+--+---+
		|  |   |
		|  +---+
		|  |   |
		+--+---+
		"""
		box_main.pack_start(paned1)
		paned1.pack1(box_savedsearches)
		paned1.pack2(paned2v)
		paned2v.pack1(box_tasklist)
		paned2v.pack2(box_bottom)
		box_bottom.pack_start(box_taskview)
		box_bottom.pack_start(box_auxtools, expand=False)
	
	main_win.show_all()
	calendar.hide()
	completion_suggestions_box.hide()
	Props['layout/layout-set'] = layout


do_layout(Props['layout/layout-set'] or '3COL')
searchbox.grab_focus()
try:
	gtk.main()
except KeyboardInterrupt:
	glib.timeout_add(100, main_quit, priority=glib.PRIORITY_DEFAULT_IDLE)
	gtk.main()
