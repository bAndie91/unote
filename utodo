#!/usr/bin/env python

import gtk
import glib
import pango
import time
import re
import glob
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory


APPNAME = 'utodo'
TODO_DIR = './test-todo.d'
TODOFILE_EXCLUDES = ['*~', '*.bak']


def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

class gtkScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget

def add_treeview_columns(treeview, columns):
	for col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_title(col_title)
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		treeview.append_column(tvc)

def main_quit():
	# execute outstanding timers
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()

class PropertyTree(dict):
	savedprops = {}
	write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.iteritems():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def load_task_texts():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(TODO_DIR), topdown=False, onerror=None, followlinks=True):
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in TODOFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			with open(filepath, 'r') as f:
				text = f.read()
				yield text

def load_tasklist():
	tasklist.clear()
	for task_text in load_task_texts():
		task_line_text = task_text.split("\n", 1)[0]
		task_line_markup = glib.markup_escape_text(task_text)
		tasklist.append(None, [task_line_text, task_line_markup, task_text])

def load_task_text(text):
	task_text_buffer.set_text(text)

def on_tasklist_selection_change(selection):
	model, iterpaths = selection.get_selected_rows()
	for iterpath in iterpaths:
		treeiter = model.get_iter(iterpath)
		task_text = model[treeiter][2]
		load_task_text(task_text)

def timer_once(sec, func, func_args=()):
	iden = func.__name__
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden]['handle'])
		del Timers[iden]
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.5, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def filter_tasklist():
	tasklist_filtered.refilter()

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	if query == '':
		return True
	task_text = model[treeiter][2]
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = model[treeiter][2].find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v



Timers = {}
Props = PropertyTree()

main_win = gtk.Window()
box1 = gtk.HBox()
paned1 = gtk.HPaned()
paned2 = gtk.HPaned()
box2 = gtk.VBox()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))

savedsearches = gtk.TreeStore(str)
savedsearches_view = gtk.TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [(_("Search"), 'text', 0)])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)

tasklist = gtk.TreeStore(str, str, str)
tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)

tasklist_view = gtk.TreeView(tasklist_filtered)
add_treeview_columns(tasklist_view, [(_("Task"), 'text', 0)])
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)


task_text_buffer = gtk.TextBuffer()
task_text_view = gtk.TextView(buffer=task_text_buffer)

searchbox = gtk.Entry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.connect('changed', on_searchbox_change)


add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
main_win.connect('delete-event', lambda *X: main_quit())


main_win.add(box1)
box1.pack_start(paned1)
paned1.pack1(gtkScrolledWidget(savedsearches_view))
paned1.pack2(paned2)
paned2.pack1(box2)
paned2.pack2(gtkScrolledWidget(task_text_view))
box2.pack_start(searchbox, expand=False)
box2.pack_start(gtkScrolledWidget(tasklist_view))

main_win.show_all()
searchbox.grab_focus()
gtk.main()
