#!/usr/bin/env python

import gtk
import glib
import pango
import time
import re
import glob
import gobject
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory


APPNAME = 'utodo'
TODO_DIR = './test-todo.d'
TODOFILE_EXCLUDES = ['*~', '*.bak']


def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget

class TextBuffer(gtk.TextBuffer):
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return self.get_text(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True)

class TreeStore(gtk.TreeStore):
	def __init__(self, columns):
		self.columns = {}
		types = []
		n = 0
		for col_name, col_type in columns:
			types.append(col_type)
			self.columns[col_name] = n
			n += 1
			super(self.__class__, self).__init__(*types)
	def get_column_num(self, col_name):
		return self.columns.get(col_name)
	def __getitem__(self, item):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				return super(self.__class__, self).__getitem__(item[0]).__getitem__(self.get_column_num(item[1]))
		return super(self.__class__, self).__getitem__(item)
	def __setitem__(self, item, value):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				super(self.__class__, self).__getitem__(item[0]).__setitem__(self.get_column_num(item[1]), value)
				return
		super(self.__class__, self).__setitem__(item, value)

class Calendar(gtk.Calendar):
	_marks = {}
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
	}
	def __init__(self):
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		self.on_paging()
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	def gotoday(self):
		now = time.localtime()
		self.select_month(now.tm_mon - 1, now.tm_year)
		self.select_day(now.tm_mday)
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in self._marks.keys():
			response.append('%04d-%02d-%02d' % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		marked = False
		for year, month, day in self._marks.keys():
			if year == c_year and month == c_month and c_day == day:
				marked = True
				del self._marks[(year, month, day)]
		if not marked:
			self._marks[(c_year, c_month, c_day)] = True
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)

def add_treeview_columns(treeview, columns):
	for col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_title(col_title)
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		treeview.append_column(tvc)

def main_quit():
	# execute outstanding timers
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()

class PropertyTree(dict):
	savedprops = {}
	write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.iteritems():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def load_task_texts():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(TODO_DIR), topdown=False, onerror=None, followlinks=True):
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in TODOFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			with open(filepath, 'r') as f:
				text = f.read()
				yield text, filepath

def load_tasklist():
	tasklist.clear()
	for task_text, task_file in load_task_texts():
		task_headline_text = task_text.split("\n", 1)[0]
		task_headline_markup = glib.markup_escape_text(task_headline_text)
		tasklist.append(None, [task_headline_markup, task_text, task_file])


def load_task_text(text):
	task_text_buffer.handler_block(eventhandle_task_text_changed)
	task_text_buffer.set_text(text)
	task_text_buffer.handler_unblock(eventhandle_task_text_changed)
	parse_task_text(text)

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[m[0:3].lower()]
	except KeyError: pass
	return m

def parse_task_text(text):
	calendar_marks = []
	re_months = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
	for y, m, d in re.findall(r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + re_months + r')-(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + re_months + r')(?:-|\s+)(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	calendar.gotoday()
	if calendar_marks:
		calendar.show()
	else:
		calendar.hide()

def on_calendar_marks_changed(*X):
	pass

def on_tasklist_selection_change(selection):
	Xmodel, iterpaths = selection.get_selected_rows()
	for iterpath in iterpaths:
		treeiter = tasklist.get_iter(iterpath)
		task_text = tasklist[(treeiter, 'raw_text')]
		load_task_text(task_text)
		task_text_view.set_data('current-task', treeiter)

def timer_once(sec, func, func_args=()):
	iden = func.__name__
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden]['handle'])
		del Timers[iden]
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.5, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def filter_tasklist():
	tasklist_filtered.refilter()

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	if query == '':
		return True
	task_text = model[(treeiter, 'raw_text')]
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = task_text.find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def save_task(treeiter):
	text = tasklist[(treeiter, 'raw_text')]
	task_file = tasklist[(treeiter, 'file')]
	with open(task_file, 'w') as f:
		f.write(text)

def on_task_text_changed(*X):
	text = task_text_buffer.get_text_all()
	treeiter = task_text_view.get_data('current-task')
	tasklist[(treeiter, 'raw_text')] = text
	timer_once(5.0, save_task, (treeiter,))


Timers = {}
Props = PropertyTree()

main_win = gtk.Window()
box1 = gtk.HBox()
paned1 = gtk.HPaned()
paned2 = gtk.HPaned()
box2 = gtk.VBox()
box3 = gtk.VBox()
box4 = gtk.HBox()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))

savedsearches = TreeStore([('query', str)])
savedsearches_view = gtk.TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [(_("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)

searchbox = gtk.Entry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.connect('changed', on_searchbox_change)

tasklist = TreeStore([('headline_markup', str), ('raw_text', str), ('file', str)])
tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)

tasklist_view = gtk.TreeView(tasklist_filtered)
add_treeview_columns(tasklist_view, [(_("Task"), 'markup', tasklist.get_column_num('headline_markup'))])
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

task_text_buffer = TextBuffer()
task_text_view = gtk.TextView(buffer=task_text_buffer)
eventhandle_task_text_changed = task_text_buffer.connect('changed', on_task_text_changed)

calendar = Calendar()
calendar.connect('marks-changed', on_calendar_marks_changed)

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
main_win.connect('delete-event', lambda *X: main_quit())


main_win.add(box1)
box1.pack_start(paned1)
paned1.pack1(ScrolledWidget(savedsearches_view))
paned1.pack2(paned2)
paned2.pack1(box2)
paned2.pack2(box3)
box3.pack_start(ScrolledWidget(task_text_view))
box3.pack_start(box4, expand=False)
box4.pack_start(calendar)
box2.pack_start(searchbox, expand=False)
box2.pack_start(ScrolledWidget(tasklist_view))

main_win.show_all()
calendar.hide()
searchbox.grab_focus()
gtk.main()
