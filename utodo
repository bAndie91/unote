#!/usr/bin/env python
# -*- coding: utf-8 -*-

import gtk
import glib
import pango
import time
import re
import glob
import gobject
fnmatch = glob.fnmatch.fnmatch
import sys
import os
import xdg.BaseDirectory
from datetime import datetime
from dateutil.relativedelta import relativedelta


APPNAME = 'utodo'
TODO_DIR = './test-todo.d'
TODOFILE_EXCLUDES = ['*~', '*.bak']


def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

class ScrolledWidget(gtk.ScrolledWindow):
	def __init__(self, widget):
		super(self.__class__, self).__init__()
		self.inner_widget = widget
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		def widget_supports_scrolling_internally(w):
			return any([isinstance(w, klass) for klass in [gtk.TextView, gtk.TreeView, gtk.Layout]])
		if widget_supports_scrolling_internally(self.inner_widget):
			self.add(self.inner_widget)
		else:
			self.add_with_viewport(self.inner_widget)
	def get_inner_widget(self):
		return self.inner_widget

class TextBuffer(gtk.TextBuffer):
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return self.get_text(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True)

class TreeStore(gtk.TreeStore):
	def __init__(self, columns):
		self.columns = {}
		types = []
		n = 0
		for col_name, col_type in columns:
			types.append(col_type)
			self.columns[col_name] = n
			n += 1
			super(self.__class__, self).__init__(*types)
	def get_column_num(self, col_name):
		return self.columns.get(col_name)
	def __getitem__(self, item):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				return super(self.__class__, self).__getitem__(item[0]).__getitem__(self.get_column_num(item[1]))
		return super(self.__class__, self).__getitem__(item)
	def __setitem__(self, item, value):
		if type(item) == tuple:
			if isinstance(item[1], basestring):
				super(self.__class__, self).__getitem__(item[0]).__setitem__(self.get_column_num(item[1]), value)
				return
		super(self.__class__, self).__setitem__(item, value)

class Calendar(gtk.Calendar):
	_marks = {}
	selected_day = (0, 0, 0)
	__gsignals__ = {
		'marks-changed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, ()),
		'mark-added': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
		'mark-removed': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (str,)),
	}
	date_format = '%04d-%02d-%02d'
	def __init__(self):
		super(self.__class__, self).__init__()
		self.set_display_options(self.get_display_options() | gtk.CALENDAR_WEEK_START_MONDAY)
		# create popup menu
		self.popup_menu = gtk.Menu()
		mi = gtk.MenuItem("Go Today")
		mi.connect('activate', self.gotoday)
		self.popup_menu.append(mi)
		self.popup_menu.show_all()
		# set initial state
		self.gotoday()
		self.connect('key-release-event', self.on_key_press_release)
		self.connect('button-press-event', self.on_mouse_click)
		self.connect('button-release-event', self.on_mouse_clicked)
		self.connect('day-selected-double-click', self.on_mark)
		self.connect('month-changed', self.on_paging)
	def on_mouse_click(self, widget, event):
		if event.button == 3:
			self.popup_menu.popup(None, None, None, event.button, event.time)
			return True  # eat the event
	def on_mouse_clicked(self, widget, event):
		if event.button == 1:
			if self.get_date()[2] != 0:
				self.on_user_select_day()
				return False  # let the event pass
	def on_key_press_release(self, widget, event):
		c_year, c_month, c_day = self.get_date()
		if event.keyval == gtk.gdk.keyval_from_name('space'):
			if c_day == self.selected_day[2]:
				self.select_day(0)
				self.selected_day = (0, 0, 0)
			else:
				self.on_user_select_day()
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Up'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=-1)
			self.select_month(date.month - 1, date.year)
		elif event.keyval == gtk.gdk.keyval_from_name('Page_Down'):
			date = datetime.strptime('%d-%d'%(c_year,c_month), '%Y-%m') + relativedelta(months=+1)
			self.select_month(date.month - 1, date.year)
	def gotoday(self, *X):
		now = time.localtime()
		self.select_month(now.tm_mon - 1, now.tm_year)
		self.select_day(now.tm_mday)
		self.selected_day = (now.tm_year, now.tm_mon, now.tm_mday)
		self.on_paging()
	def get_date(self):
		y, m, d = super(self.__class__, self).get_date()
		return y, m+1, d
	def set_marks(self, marks):
		self._marks = {}
		for mark in marks:
			self._marks[tuple(map(int, mark.split('-')))] = True
		self.on_paging()
	def get_marks(self):
		response = []
		for year, month, day in self._marks.keys():
			response.append(date_format % (year, month, day))
		return response
	def on_mark(self, *X):
		c_year, c_month, c_day = self.get_date()
		was_marked = False
		for year, month, day in self._marks.keys():
			if year == c_year and month == c_month and c_day == day:
				was_marked = True
				del self._marks[(year, month, day)]
		if was_marked:
			self.emit('mark-removed', self.date_format % (c_year, c_month, c_day))
		else:
			self._marks[(c_year, c_month, c_day)] = True
			self.emit('mark-added', self.date_format % (c_year, c_month, c_day))
		self.on_paging()
		self.emit('marks-changed')
	def on_paging(self, *X):
		self.clear_marks()
		self.select_day(0)
		c_year, c_month, c_day = self.get_date()
		for year, month, day in self._marks:
			if (year == 0 or year == c_year) and month == c_month:
				super(self.__class__, self).mark_day(day)
		if c_year == self.selected_day[0] and c_month == self.selected_day[1]:
			self.select_day(self.selected_day[2])
	def on_user_select_day(self, *X):
		self.selected_day = self.get_date()

class ActionStockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None, action=None):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)
		if action is not None:
			self.connect('activate', action)

def add_treeview_columns(treeview, columns):
	for col_title, col_attr, col_num in columns:
		tvc = gtk.TreeViewColumn()
		tvc.set_title(col_title)
		cr_txt = gtk.CellRendererText()
		tvc.pack_start(cr_txt, True)
		tvc.add_attribute(cr_txt, col_attr, col_num)
		treeview.append_column(tvc)

def main_quit():
	# execute outstanding timers
	for iden in Timers.keys():
		glib.source_remove(Timers[iden]['handle'])
		timer_call(iden, Timers[iden]['func'], Timers[iden]['args'])
	# quit gtk loop
	gtk.main_quit()

def _(s):
	return s

def program_start(widget, event):
	widget.disconnect(start_event_handle)
	main_win.connect('configure-event', on_window_configure)
	load_tasklist()

class PropertyTree(dict):
	savedprops = {}
	write_delay = 1.0
	def __getitem__(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
				if propvalue is not None:
					self.savedprops[propname] = propvalue
					super(self.__class__, self).__setitem__(propname, propvalue)
					break
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer_once(self.write_delay, self._write)
	def _write(self):
		for propname, propvalue in self.iteritems():
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				with open(propfile, 'w') as f:
					f.write(str(self[propname]))
				self.savedprops[propname] = propvalue

def getprops(*props):
	values = []
	for prop in props:
		values.append(Props[prop])
	return values

def load_task_texts():
	for dirpath, dirnames, filenames in os.walk(os.path.expanduser(TODO_DIR), topdown=False, onerror=None, followlinks=True):
		for filename in filenames:
			if any([fnmatch(filename, pattern) for pattern in TODOFILE_EXCLUDES]):
				continue
			filepath = os.path.join(dirpath, filename)
			with open(filepath, 'r') as f:
				text = f.read()
				yield text, filepath

def load_tasklist():
	tasklist.clear()
	for task_text, task_file in load_task_texts():
		task_headline_text = task_text.split("\n", 1)[0]
		task_headline_markup = glib.markup_escape_text(task_headline_text)
		tasklist.append(None, [task_headline_markup, task_text, task_file])


def load_task_text(text):
	task_text_buffer.handler_block(eventhandle_task_text_changed)
	task_text_buffer.set_text(text)
	task_text_buffer.handler_unblock(eventhandle_task_text_changed)
	parse_task_text(text)
	calendar.gotoday()

def month_name_to_number(m):
	monthabbrevations = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}
	try: m = monthabbrevations[m[0:3].lower()]
	except KeyError: pass
	return m

def parse_task_text(text):
	calendar_marks = []
	re_months = r'jan|febr?|marc?|apr|may|jun|jul|aug|sept?|oct|nov|dec'
	for y, m, d in re.findall(r'\b([0-9]{4})-(0?[1-9]|1[0-2]|' + re_months + r')-(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('%d-%d-%d' % (int(y), int(month_name_to_number(m)), int(d)))
	for m, d in re.findall(r'\b(' + re_months + r')(?:-|\s+)(0?[1-9]|[12][0-9]|3[01])\b', text, re.I):
		calendar_marks.append('0-%d-%d' % (int(month_name_to_number(m)), int(d)))
	calendar.set_marks(calendar_marks)
	if calendar_marks or re.search(r'\bdate:', text):
		if not calendar.get_visible():
			calendar.gotoday()
		calendar.show()
	else:
		calendar.hide()

def on_tasklist_selection_change(selection):
	Xmodel, iterpaths = selection.get_selected_rows()
	for iterpath in iterpaths:
		treeiter = tasklist.get_iter(iterpath)
		task_text = tasklist[(treeiter, 'raw_text')]
		load_task_text(task_text)
		task_text_view.set_data('current-task', treeiter)

def timer_once(sec, func, func_args=()):
	iden = func.__name__
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden]['handle'])
		del Timers[iden]
	if func is not None:
		Timers[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer_call, iden, func, func_args),
			'func': func,
			'args': func_args,
		}

def timer_call(iden, func, args):
	del Timers[iden]
	func(*args)
	return False

def on_searchbox_change(*X):
	timer_once(0.5, filter_tasklist)
	Props['field/search/text'] = searchbox.get_text()

def filter_tasklist():
	tasklist_filtered.refilter()

def tasklist_filterer(model, treeiter):
	query = searchbox.get_text()
	query = query.strip()
	if query == '':
		return True
	task_text = model[(treeiter, 'raw_text')]
	query_match = False
	if task_text is not None:
		for query_alternative in re.split(r'\s*,\s*', query):
			query_alternative = query_alternative.strip()
			if query_alternative == '':
				continue
			alternative_match = True
			query_clauses = re.split(r'(?:\bNOT\b|!)', query_alternative, 1, re.I)
			if len(query_clauses) == 1:
				query_positive = query_clauses[0]
				query_negative = ''
			else:
				query_positive, query_negative = query_clauses
			for query_clause, positive_match in (query_positive, True), (query_negative, False):
				for query_word in re.split(r'\s+', query_clause):
					if query_word == '':
						continue
					word_match = task_text.find(query_word) > -1
					if (positive_match and not word_match) or (not positive_match and word_match):
						alternative_match = False
						break
				if not alternative_match:
					break
			if alternative_match:
				query_match = True
				break
	return query_match

def on_window_configure(widget, event):
	for k, v in ('position/x', event.x), ('position/y', event.y), ('size/width', event.width), ('size/height', event.height):
		Props['layout/window/%s' % k] = v

def save_task(treeiter):
	text = tasklist[(treeiter, 'raw_text')]
	task_file = tasklist[(treeiter, 'file')]
	with open(task_file, 'w') as f:
		f.write(text)

def on_task_text_changed(*X):
	text = task_text_buffer.get_text_all()
	# represent task text in the task list
	treeiter = task_text_view.get_data('current-task')
	tasklist[(treeiter, 'raw_text')] = text
	# re-parse
	parse_task_text(text)
	# schedule save
	timer_once(5.0, save_task, (treeiter,))

def act_change_font(*X):
	def get_current_font(textview):
		pctx = textview.get_pango_context()
		fdsc = pctx.get_font_description()
		return fdsc.to_string()
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(main_win)
	dlg.set_modal(True)
	dlg.set_font_name(Props['font'] or get_current_font(task_text_view))
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['field/task_text/font'] = font_name
		task_text_view.modify_font(pango.FontDescription(font_name))
	dlg.destroy()

def on_task_text_view_menu(Xtextview, menu):
	pos = 0
	mi = ActionStockMenuItem(label=_("Default Font…"), stock_id=gtk.STOCK_SELECT_FONT, action=act_change_font)
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos += 1
	menu.show_all()

def task_text_append_line(s):
	if task_text_buffer.get_text_all()[-1] != '\n': s = '\n' + s
	if s[-1] != '\n': s = s + '\n'
	task_text_buffer.append(s)

def str_replace_last(s, f, r):
	pos = s.rfind(f)
	if pos == -1: return s
	return s[0:pos] + r + s[pos+len(f):]

def task_text_remove_last(s):
	"""removes last occurrance of s from task_text.
	removes newline if s is a complete line."""
	text = task_text_buffer.get_text_all()
	ln = s
	if ln[0] != '\n': ln = '\n' + ln
	if ln[-1] != '\n': ln = ln + '\n'
	newtext = str_replace_last(text, ln, '\n')
	if newtext == text:
		newtext = str_replace_last(text, s, '')
	task_text_buffer.set_text(newtext)


Timers = {}
Props = PropertyTree()

main_win = gtk.Window()
box1 = gtk.HBox()
paned1 = gtk.HPaned()
paned2 = gtk.HPaned()
box2 = gtk.VBox()
box3 = gtk.VBox()
box4 = gtk.HBox()

try: main_win.resize(*map(int, getprops('layout/window/size/width', 'layout/window/size/height')))
except (ValueError, TypeError): pass
try: main_win.move(*map(int, getprops('layout/window/position/x', 'layout/window/position/y')))
except (ValueError, TypeError): pass
try: paned1.set_position(*map(int, getprops('layout/panel/savedsearches/width')))
except (ValueError, TypeError): pass
try: paned2.set_position(*map(int, getprops('layout/panel/tasklist/width')))
except (ValueError, TypeError): pass

start_event_handle = main_win.connect('map-event', program_start)
paned1.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/savedsearches/width', paned.get_position())))
paned2.connect('notify::position', lambda paned, pos: timer_once(1.5, lambda: Props.__setitem__('layout/panel/tasklist/width', paned.get_position())))

savedsearches = TreeStore([('query', str)])
savedsearches_view = gtk.TreeView(savedsearches)
add_treeview_columns(savedsearches_view, [(_("Search"), 'text', savedsearches.get_column_num('query'))])
savedsearches_view.set_reorderable(True)
savedsearches_view.set_headers_clickable(True)

savedsearches_selection = savedsearches_view.get_selection()
savedsearches_selection.set_mode(gtk.SELECTION_MULTIPLE)

searchbox = gtk.Entry()
searchbox.set_text(Props.get('field/search/text', ''))
searchbox.connect('changed', on_searchbox_change)

tasklist = TreeStore([('headline_markup', str), ('raw_text', str), ('file', str)])
tasklist_filtered = tasklist.filter_new()
tasklist_filtered.set_visible_func(tasklist_filterer)

tasklist_view = gtk.TreeView(tasklist_filtered)
add_treeview_columns(tasklist_view, [(_("Task"), 'markup', tasklist.get_column_num('headline_markup'))])
tasklist_view.set_reorderable(True)
tasklist_view.set_headers_clickable(True)

tasklist_selection = tasklist_view.get_selection()
tasklist_selection.set_mode(gtk.SELECTION_MULTIPLE)
tasklist_selection.connect('changed', on_tasklist_selection_change)

task_text_buffer = TextBuffer()
task_text_view = gtk.TextView(buffer=task_text_buffer)
task_text_view.modify_font(pango.FontDescription(Props['field/task_text/font'] or ''))
eventhandle_task_text_changed = task_text_buffer.connect('changed', on_task_text_changed)
task_text_view.connect('populate-popup', on_task_text_view_menu)


calendar = Calendar()
calendar.connect('mark-added', lambda X, date: task_text_append_line(date))
calendar.connect('mark-removed', lambda X, date: task_text_remove_last(date))

add_key_binding(main_win, '<Control>q', lambda *X: main_quit())
main_win.connect('delete-event', lambda *X: main_quit())


main_win.add(box1)
box1.pack_start(paned1)
paned1.pack1(ScrolledWidget(savedsearches_view))
paned1.pack2(paned2)
paned2.pack1(box2)
paned2.pack2(box3)
box3.pack_start(ScrolledWidget(task_text_view))
box3.pack_start(box4, expand=False)
box4.pack_start(calendar)
box2.pack_start(searchbox, expand=False)
box2.pack_start(ScrolledWidget(tasklist_view))

main_win.show_all()
calendar.hide()
searchbox.grab_focus()
gtk.main()
